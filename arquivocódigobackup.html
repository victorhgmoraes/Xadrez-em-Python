import pygame as x
import xadrezBack, IAXadrez
import sys
from multiprocessing import Process, Queue

LARGURATABULEIRO = ALTURATABULEIRO = 612
LARGURAPAINELMOVELOG = 250
ALTURAPAINELMOVELOG = ALTURATABULEIRO #// 1/8 * 7
LARGURAINFORMACOESJOGO = LARGURATABULEIRO + LARGURAPAINELMOVELOG
DIMENSAO = 8
SQ_SIZE = ALTURATABULEIRO // DIMENSAO
ALTURAINFORMACOESJOGO = SQ_SIZE
MAX_FPS = 15 #15 de acordo com o video
IMAGENS = {}

def CarregarImagens():
    pecas = ['wP','wR','wQ','wK','wN','wB','bP','bR','bN','bB','bK','bQ']
    for peca in pecas:
        IMAGENS[peca] = x.transform.scale(x.image.load("imagens/" + peca + ".png"), (SQ_SIZE, SQ_SIZE))
        #É possível acessar uma imagem dizendo'IMAGES['wP']'

def Principal():
    x.init()
    tela = x.display.set_mode((LARGURATABULEIRO + LARGURAPAINELMOVELOG, ALTURAINFORMACOESJOGO + ALTURATABULEIRO))
    # Chamar a seleção do modo de jogo
    JogadorUm, JogadorDois = DesenharModoJogo(tela)
    if JogadorUm is None and JogadorDois is None:
        return  # Caso o jogador feche o jogo na tela de seleção, encerrar o programa
    tempoSelecionado = SelecionarTempoDeJogo(tela)
    tempoJogador1 = tempoSelecionado * 60  # Tempo em segundos
    tempoJogador2 = tempoSelecionado * 60
    ultimoTempo = x.time.get_ticks()  # Marcar o tempo inicial
    if tempoSelecionado is None:
        return  # Se o jogador fechar a tela, encerre o programa
    tempo = x.time.Clock()
    tela.fill(x.Color("white"))
    MoveLogFonte = x.font.SysFont("Arial", 14, False, False)
    aj = xadrezBack.ArmazenamentoJogo()
    MovimentosValidos = aj.getMovimentosValidos()
    MovimentoFeito = False #variavel flag para quando um movimento é feito
    animar = False # variavel flag para quando formos animar um movimento
    CarregarImagens()
    #apenas fazer 1 vez, antes do looping while
    running = True
    QuadSelecionado = () #nenhum quadrado selecionado, manter informação do ultimo clique do usuário (tupla: (linha, coluna))
    CliquesJogador = [] #manter informação dos cliques do jogador (2 tuplas [(6,4),(4,4)])
    FimDoJogo = False
    IAPensando = False
    ProcessoEncontrarMovimento = None
    MovimentoDesfeito = False
    cronometroIniciado = False  # Flag para indicar se o cronômetro já foi iniciado
    vitorias_jogador1 = 0
    vitorias_jogador2 = 0
    while running:
        TurnoPessoa = (aj.whiteToMove and JogadorUm) or (not aj.whiteToMove and JogadorDois)
        for e in x.event.get():
            if e.type == x.QUIT:
                x.quit()
                sys.exit()
            #mouse handler
            elif e.type == x.MOUSEBUTTONDOWN:
                if not FimDoJogo:
                    localizacao = x.mouse.get_pos() #posição do mouse
                    col = localizacao[0]//SQ_SIZE
                    linha = localizacao[1]//SQ_SIZE
                    if QuadSelecionado == (linha, col) or col >= 8: #O usuário clicou no mesmo quadrado duas vezes
                        QuadSelecionado = () #deselecionar
                        CliquesJogador = [] #limpar cliques do jogador
                    else:
                        QuadSelecionado = (linha, col)
                        CliquesJogador.append(QuadSelecionado) #append nos dois primeiro e segundon cliques
                    if len(CliquesJogador) == 2 and TurnoPessoa: #depois do segundo clique
                        mover = xadrezBack.Movimento(CliquesJogador[0], CliquesJogador[1], aj.tabuleiro)
                        print(mover.getNotacaoXadrez())
                        for i in range(len(MovimentosValidos)):
                            if mover == MovimentosValidos[i]:
                                aj.FazerMovimento(MovimentosValidos[i], tela)
                                MovimentoFeito = True
                                animar = True
                                QuadSelecionado = () #resetar cliques do usuário
                                CliquesJogador = []
                                if not cronometroIniciado:  # Iniciar cronômetro após o primeiro movimento
                                    cronometroIniciado = True
                        if not MovimentoFeito:
                            CliquesJogador = [QuadSelecionado]
            #key handlers
            elif e.type == x.KEYDOWN:
                if e.key == x.K_z: #desfaz quando 'z' é pressionado
                    aj.DesfazerMovimento()
                    MovimentoFeito = True
                    animar = False
                    FimDoJogo = False
                    if IAPensando:
                        ProcessoEncontrarMovimento.terminate()
                        IAPensando = False
                    MovimentoDesfeito = True
                if e.key == x.K_r: #resetar o tabuleiro quando a tecla 'r' é pressionada
                    aj = xadrezBack.ArmazenamentoJogo()
                    MovimentosValidos = aj.getMovimentosValidos()
                    QuadSelecionado = ()
                    CliquesJogador = []
                    MovimentoFeito = False
                    animar = False
                    FimDoJogo = False
                    if IAPensando:
                        ProcessoEncontrarMovimento.terminate()
                        IAPensando = False
                    MovimentoDesfeito = True
                    # Reiniciar os cronômetros
                    tempoJogador1 = tempoSelecionado * 60  # Reiniciar tempo do jogador 1
                    tempoJogador2 = tempoSelecionado * 60  # Reiniciar tempo do jogador 2
                    cronometroIniciado = False  # Redefinir a flag do cronômetro
        #Localizador de movimento IA
        if not FimDoJogo and not TurnoPessoa and not MovimentoDesfeito:
            if not IAPensando:
                IAPensando = True
                print("Pensando...")
                returnQueue = Queue() #usado para passar dados entre sequencias de programas
                ProcessoEncontrarMovimento = Process(target = IAXadrez.EncontrarMelhorMovimento, args = (aj, MovimentosValidos, returnQueue))
                ProcessoEncontrarMovimento.start() #chama EncontrarMelhorMovimento(aj, movimentosValidos, returnQueue)
                
            if not ProcessoEncontrarMovimento.is_alive():
                MovimentoIA = returnQueue.get()
                if MovimentoIA is None:
                    MovimentoIA = IAXadrez.EncontrarMovimentoAleatorio(MovimentosValidos)
                aj.FazerMovimento(MovimentoIA)
                MovimentoFeito = True
                animar = True
                IAPensando = False

        if MovimentoFeito:
            if animar:
                MovimentoAnimado(aj.MoveLog[-1], tela, aj.tabuleiro, tempo)
            MovimentosValidos = aj.getMovimentosValidos()
            MovimentoFeito = False
            animar = False
            MovimentoDesfeito = False

        tempoAtual = x.time.get_ticks()
        deltaTempo = (tempoAtual - ultimoTempo) / 1000  # Diferença em segundos
        ultimoTempo = tempoAtual

        if aj.whiteToMove:  # Turno do jogador 1 (brancas)
            tempoJogador1 -= deltaTempo if cronometroIniciado else 0
        else:  # Turno do jogador 2 (pretas)
            tempoJogador2 -= deltaTempo if cronometroIniciado else 0

        FazerJogo(tela, aj, MovimentosValidos, QuadSelecionado, MoveLogFonte)
        DesenharInformacoesJogo(tela, aj, 0, 0, tempoJogador1, tempoJogador2, vitorias_jogador1, vitorias_jogador2)

        if tempoJogador1 <= 0:
            if not FimDoJogo:
                FimDoJogo = True
                vitorias_jogador2 += 1  # Incrementar vitórias do jogador 2
                DesenharTextoFimDeJogo(tela, 'Pretas vencem por tempo')
                # Pausa por 3000 milissegundos (3 segundos)
                x.display.update()  # Atualiza a tela para mostrar a mensagem
                x.time.delay(3000)  # Atraso de 3 segundos antes de prosseguir
        elif tempoJogador2 <= 0:
            if not FimDoJogo:
                FimDoJogo = True
                vitorias_jogador1 += 1  # Incrementar vitórias do jogador 1
                DesenharTextoFimDeJogo(tela, 'Brancas vencem por tempo')
                # Pausa por 3000 milissegundos (3 segundos)
                x.display.update()  # Atualiza a tela para mostrar a mensagem
                x.time.delay(3000)  # Atraso de 3 segundos antes de prosseguir
        # Verifica se houve chequemate, impasse, empate por 50 movimentos, ou insuficiência de material
        if aj.Chequemate or aj.Impasse or aj.Empate50Movimentos or aj.verificar_empate_por_insuficiencia_material(aj.tabuleiro):
            if not FimDoJogo:
                FimDoJogo = True
                if aj.Empate50Movimentos:
                    DesenharTextoFimDeJogo(tela, 'Empate por 50 movimentos')
                elif aj.Impasse: 
                    DesenharTextoFimDeJogo(tela, 'Empate por Afogamento')
                elif aj.verificar_empate_por_insuficiencia_material(aj.tabuleiro):
                    DesenharTextoFimDeJogo(tela, 'Empate por insuficiência de material')
                else:
                    # Caso de chequemate
                    vitorias_jogador2 += 1 if aj.whiteToMove else 0
                    vitorias_jogador1 += 1 if not aj.whiteToMove else 0
                    DesenharTextoFimDeJogo(tela, 'Pretas vencem por chequemate' if aj.whiteToMove else 'Brancas vencem por chequemate')
                
                # Pausa de 3 segundos para mostrar a mensagem de fim do jogo
                x.display.update()  # Atualiza a tela para mostrar a mensagem
                x.time.delay(3000)  # Atraso de 3 segundos antes de prosseguir

        # Atualização da tela e controle de FPS
        tempo.tick(MAX_FPS)
        x.display.flip()

'''
Responsável pela parte gráfica
'''

def FazerJogo(tela, aj, MovimentosValidos, QuadSelecionado, MoveLogFonte):
    # Ajuste as coordenadas para onde as informações do jogo serão desenhadas
    x_offset = 0  # Ajuste conforme necessário, a posição X para desenhar as informações do jogo
    y_offset = ALTURATABULEIRO + 10  # Posição Y para desenhar as informações do jogo, logo abaixo do tabuleiro
    DesenharTabuleiro(tela) #desenhar quadrados
    QuadradosBrilhantes(tela, aj, MovimentosValidos, QuadSelecionado)
    DesenharPecas(tela, aj.tabuleiro) #desenhar peças no topo dos quadrados
    DesenharMoveLog(tela, aj, MoveLogFonte)

def checar_empate_repeticao(tela, aj):
    if aj.verificar_repeticao_movimentos():
        DesenharTextoFimDeJogo(tela, 'Repetição de 3 movimentos detectada. \n Declarar empate?')
        empate = DesenharBotaoEmpate3Movimentos(tela)
        if empate:
            return True  # Retorna True se o jogador declarar empate
    return False

"""
Função para desenhar botões 'Sim' e 'Não' para o empate por repetição de três movimentos.
Retorna True se o jogador escolher empatar, False caso contrário.
"""

def DesenharBotaoEmpate3Movimentos(tela):
    fonte = x.font.SysFont("Arial", 36, True, False)
    textoSim = fonte.render("Sim", True, x.Color("white"))
    textoNao = fonte.render("Não", True, x.Color("white"))

    larguraBotao = textoSim.get_width() + 50
    alturaBotao = textoSim.get_height() + 20

    distanciaAbaixoTexto = 80
    botaoSim = x.Rect(LARGURATABULEIRO // 2 - larguraBotao // 2 - 70, ALTURATABULEIRO // 2 + distanciaAbaixoTexto, larguraBotao, alturaBotao)
    botaoNao = x.Rect(LARGURATABULEIRO // 2 + larguraBotao // 2 - 40, ALTURATABULEIRO // 2 + distanciaAbaixoTexto, larguraBotao, alturaBotao)

    desenharBotao(tela, botaoSim, textoSim)
    desenharBotao(tela, botaoNao, textoNao)
    x.display.update()

    # Retorna os botões, e a lógica de verificação fica no loop principal
    return botaoSim, botaoNao

'''
Desenhar Seleção de modo de jogo
'''
def DesenharModoJogo(tela):
    fonteTitulo = x.font.SysFont("Arial", 48, True, False)
    fonteBotao = x.font.SysFont("Arial", 36, True, False)
    # Carrega e redimensiona a imagem de fundo
    imagemDeFundo = x.image.load("imagens/xadrez.jpg")  # Substitua pelo caminho da sua imagem
    imagemDeFundo = x.transform.scale(imagemDeFundo, (LARGURATABULEIRO + LARGURAPAINELMOVELOG, ALTURATABULEIRO + ALTURAINFORMACOESJOGO))
    # Desenha a imagem de fundo
    tela.blit(imagemDeFundo, (0, 0))
    # Desenha o título com sombra
    tituloTexto = fonteTitulo.render("Selecione o Modo de Jogo", True, x.Color("white"))
    sombraTitulo = fonteTitulo.render("Selecione o Modo de Jogo", True, x.Color("black"))
    # Centralizar o título
    tituloX = (LARGURATABULEIRO + LARGURAPAINELMOVELOG) // 2 - tituloTexto.get_width() // 2
    tituloY = ALTURATABULEIRO // 4
    tela.blit(sombraTitulo, (tituloX + 2, tituloY + 2))  # Sombra
    tela.blit(tituloTexto, (tituloX, tituloY))  # Texto principal
    # Desenhar os botões
    modoPessoaPessoa = fonteBotao.render("Pessoa vs Pessoa", True, x.Color("white"))
    modoPessoaIA = fonteBotao.render("Pessoa vs IA", True, x.Color("white"))
    # Configuração dos botões
    larguraBotao = max(modoPessoaPessoa.get_width(), modoPessoaIA.get_width()) + 40
    alturaBotao = modoPessoaPessoa.get_height() + 20
    botaoPessoaPessoa = x.Rect((LARGURATABULEIRO + LARGURAPAINELMOVELOG) // 2 - larguraBotao // 2, 
                               ALTURATABULEIRO // 2 - 60, larguraBotao, alturaBotao)
    botaoPessoaIA = x.Rect((LARGURATABULEIRO + LARGURAPAINELMOVELOG) // 2 - larguraBotao // 2, 
                           ALTURATABULEIRO // 2 + 60, larguraBotao, alturaBotao)
    # Desenho dos botões com bordas arredondadas
    desenharBotao(tela, botaoPessoaPessoa, modoPessoaPessoa)
    desenharBotao(tela, botaoPessoaIA, modoPessoaIA)
    x.display.flip()
    # Lógica de interação do usuário
    esperandoEscolha = True
    while esperandoEscolha:
        for e in x.event.get():
            if e.type == x.QUIT:
                return None, None  # Ao fechar a janela, retornar None para encerrar o jogo
            elif e.type == x.MOUSEBUTTONDOWN:
                pos = x.mouse.get_pos()

                # Verifica se o clique foi em um dos botões
                if botaoPessoaPessoa.collidepoint(pos):
                    return True, True  # Ambos jogadores são pessoas
                elif botaoPessoaIA.collidepoint(pos):
                    return True, False  # Jogador 1 é pessoa, Jogador 2 é IA
            # Efeito de hover (realce ao passar o mouse)
            pos = x.mouse.get_pos()
            if botaoPessoaPessoa.collidepoint(pos):
                desenharBotao(tela, botaoPessoaPessoa, modoPessoaPessoa, corBotao=(34, 40, 49))  # Realçar
            else:
                desenharBotao(tela, botaoPessoaPessoa, modoPessoaPessoa)
            if botaoPessoaIA.collidepoint(pos):
                desenharBotao(tela, botaoPessoaIA, modoPessoaIA, corBotao=(34, 40, 49))  # Realçar
            else:
                desenharBotao(tela, botaoPessoaIA, modoPessoaIA)
            x.display.flip()

# Função auxiliar para desenhar botões com bordas arredondadas
def desenharBotao(tela, retangulo, texto, corBotao=(57, 54, 70), corBorda=(109, 93, 110), larguraBorda=5):
    # Desenha a borda arredondada
    x.draw.rect(tela, corBorda, retangulo.inflate(10, 10), border_radius=15)
    # Desenha o fundo do botão
    x.draw.rect(tela, corBotao, retangulo, border_radius=15)
    # Renderiza o texto no centro do botão
    tela.blit(texto, (retangulo.x + (retangulo.width - texto.get_width()) // 2, 
                      retangulo.y + (retangulo.height - texto.get_height()) // 2))

def SelecionarTempoDeJogo(tela):
    fonteTitulo = x.font.SysFont("Arial", 48, True, False)
    fonteBotao = x.font.SysFont("Arial", 36, True, False)
    # Carrega e redimensiona a imagem de fundo
    imagemDeFundo = x.image.load("imagens/xadrez.jpg")  # Substitua pelo caminho da sua imagem
    imagemDeFundo = x.transform.scale(imagemDeFundo, (LARGURATABULEIRO + LARGURAPAINELMOVELOG, ALTURATABULEIRO + ALTURAINFORMACOESJOGO))
    # Desenha a imagem de fundo
    tela.blit(imagemDeFundo, (0, 0))
    # Desenha o título com sombra
    tituloTexto = fonteTitulo.render("Escolha o tempo de jogo", True, x.Color("white"))
    sombraTitulo = fonteTitulo.render("Escolha o tempo de jogo", True, x.Color("black"))
    # Centralizar o título
    tituloX = (LARGURATABULEIRO + LARGURAPAINELMOVELOG) // 2 - tituloTexto.get_width() // 2
    tituloY = ALTURATABULEIRO // 4
    tela.blit(sombraTitulo, (tituloX + 2, tituloY + 2))  # Sombra
    tela.blit(tituloTexto, (tituloX, tituloY))  # Texto principal
    # Desenhar os botões
    botao30Min = fonteBotao.render("30 minutos", True, x.Color("white"))
    botao10Min = fonteBotao.render("10 minutos", True, x.Color("white"))
    botao3Min = fonteBotao.render("3 minutos", True, x.Color("white"))
    # Configuração dos botões
    larguraBotao = max(botao30Min.get_width(), botao10Min.get_width(), botao3Min.get_width()) + 40
    alturaBotao = botao30Min.get_height() + 20
    # Adiciona a margem de 20 pixels entre os botões
    margem = 20
    botao30MinRect = x.Rect((LARGURATABULEIRO + LARGURAPAINELMOVELOG) // 2 - larguraBotao // 2, 
                             ALTURATABULEIRO // 2 - 60, larguraBotao, alturaBotao)
    botao10MinRect = x.Rect((LARGURATABULEIRO + LARGURAPAINELMOVELOG) // 2 - larguraBotao // 2, 
                            botao30MinRect.bottom + margem, larguraBotao, alturaBotao)
    botao3MinRect = x.Rect((LARGURATABULEIRO + LARGURAPAINELMOVELOG) // 2 - larguraBotao // 2, 
                            botao10MinRect.bottom + margem, larguraBotao, alturaBotao)
    # Desenho dos botões com bordas arredondadas
    desenharBotao(tela, botao30MinRect, botao30Min)
    desenharBotao(tela, botao10MinRect, botao10Min)
    desenharBotao(tela, botao3MinRect, botao3Min)
    x.display.flip()

    # Lógica de interação do usuário
    esperandoEscolha = True
    while esperandoEscolha:
        for e in x.event.get():
            if e.type == x.QUIT:
                return None  # Ao fechar a janela, retornar None para encerrar o jogo
            elif e.type == x.MOUSEBUTTONDOWN:
                pos = x.mouse.get_pos()
                # Verifica se o clique foi em um dos botões
                if botao30MinRect.collidepoint(pos):
                    return 30  # Retorna 30 minutos
                elif botao10MinRect.collidepoint(pos):
                    return 10  # Retorna 10 minutos
                elif botao3MinRect.collidepoint(pos):
                    return 3  # Retorna 3 minutos            
            # Efeito de hover (realce ao passar o mouse)
            pos = x.mouse.get_pos()
            if botao30MinRect.collidepoint(pos):
                desenharBotao(tela, botao30MinRect, botao30Min, corBotao=(34, 40, 49))  # Realçar
            else:
                desenharBotao(tela, botao30MinRect, botao30Min)               
            if botao10MinRect.collidepoint(pos):
                desenharBotao(tela, botao10MinRect, botao10Min, corBotao=(34, 40, 49))  # Realçar
            else:
                desenharBotao(tela, botao10MinRect, botao10Min)
            if botao3MinRect.collidepoint(pos):
                desenharBotao(tela, botao3MinRect, botao3Min, corBotao=(34, 40, 49))  # Realçar
            else:
                desenharBotao(tela, botao3MinRect, botao3Min)
            x.display.flip()

# Função auxiliar para desenhar botões com bordas arredondadas
def desenharBotao(tela, retangulo, texto, corBotao=(57, 54, 70), corBorda=(109, 93, 110), larguraBorda=5):
    # Desenha a borda arredondada
    x.draw.rect(tela, corBorda, retangulo.inflate(10, 10), border_radius=15)
    # Desenha o fundo do botão
    x.draw.rect(tela, corBotao, retangulo, border_radius=15)
    # Renderiza o texto no centro do botão
    tela.blit(texto, (retangulo.x + (retangulo.width - texto.get_width()) // 2, 
                      retangulo.y + (retangulo.height - texto.get_height()) // 2))

'''
Desenhar quadrados
'''

def DesenharTabuleiro(tela):
    global cores
    cores = [x.Color("White"), x.Color("grey")]
    for l in range(DIMENSAO):
        for c in range(DIMENSAO):
            cor = cores[((l + c) % 2)]
            x.draw.rect(tela, cor, x.Rect(c*SQ_SIZE, l*SQ_SIZE, SQ_SIZE, SQ_SIZE))

def DesenharInformacoesJogo(tela, aj, x_offset, y_offset, tempoJogador1, tempoJogador2, vitorias_jogador1, vitorias_jogador2):
    # Ajuste a posição Y para colocar a faixa branca apenas na parte inferior da tela
    InformacoesJogoRect = x.Rect(0, ALTURATABULEIRO, LARGURAINFORMACOESJOGO, ALTURAINFORMACOESJOGO)
    x.draw.rect(tela, x.Color('white'), InformacoesJogoRect)
    # Assumindo que aj.pontuacaoBrancas, aj.pontuacaoPretas e aj.tempo_restante estão definidos
    fonte = x.font.SysFont("Arial", 32, True, False)
    # Garantir que o tempo não seja negativo
    if tempoJogador1 < 0:
        tempoJogador1 = 0
    if tempoJogador2 < 0:
        tempoJogador2 = 0
    tempoJogador1Texto = fonte.render(f"J1: {int(tempoJogador1//60)}:{int(tempoJogador1%60):02d}", True, x.Color('black'))
    tempoJogador2Texto = fonte.render(f"J2: {int(tempoJogador2//60)}:{int(tempoJogador2%60):02d}", True, x.Color('black'))
    texto_placar = fonte.render(f"Placar: {vitorias_jogador1} - {vitorias_jogador2}", True, x.Color('black'))
    # Exibir o tempo abaixo do tabuleiro, centralizado
    # Ajustando as posições dos textos
    tela.blit(tempoJogador1Texto, (LARGURATABULEIRO//2 - tempoJogador1Texto.get_width() - 150, ALTURATABULEIRO + 20 + y_offset))
    tela.blit(tempoJogador2Texto, (LARGURATABULEIRO//2 -100, ALTURATABULEIRO + 20 + y_offset))
    tela.blit(texto_placar, (LARGURATABULEIRO//2 + 90, ALTURATABULEIRO + 20 + y_offset))
    # Criar o botão de empate
    botao_empate_rect = x.Rect(LARGURATABULEIRO//2 + 305, ALTURATABULEIRO + y_offset, 255, 400)  # Botão centralizado
    x.draw.rect(tela, x.Color('lightgray'), botao_empate_rect)  # Cor do botão
    texto_empate = fonte.render("Empate", True, x.Color('black'))
    tela.blit(texto_empate, (botao_empate_rect.x + 70, botao_empate_rect.y + 20))  # Posiciona o texto no botão

'''
quadrado brilhante selecionado e movimentos para peça selecionada
'''

def QuadradosBrilhantes(tela, aj, MovimentosValidos, QuadSelecionado):
    if (len(aj.MoveLog)) > 0:
        UltimoMovimento = aj.MoveLog[-1]
        s = x.Surface((SQ_SIZE, SQ_SIZE))
        s.set_alpha(100)
        s.fill(x.Color('green'))
        tela.blit(s, (UltimoMovimento.ColFinal * SQ_SIZE, UltimoMovimento.LinhaFinal * SQ_SIZE))
    if QuadSelecionado != ():
        l, c = QuadSelecionado
        if aj.tabuleiro[l][c][0] == (
                'w' if aj.whiteToMove else 'b'):  # Quadrado selecionado é uma peça que pode ser movida
            # Quadrado brilhante selecionado
            s = x.Surface((SQ_SIZE, SQ_SIZE))
            s.set_alpha(100)  # Valor de transparência 0 -> transparentw, 255 -> opaco
            s.fill(x.Color('blue'))
            tela.blit(s, (c * SQ_SIZE, l * SQ_SIZE))
            # movimentos brilhantes desse quadrado
            s.fill(x.Color('yellow'))
            for mover in MovimentosValidos:
                if mover.LinhaInicial == l and mover.ColInicial == c:
                    tela.blit(s, (mover.ColFinal * SQ_SIZE, mover.LinhaFinal * SQ_SIZE))
'''
Desenhar peças
'''
def DesenharPecas(tela, tabuleiro):
    for l in range(DIMENSAO):
        for c in range(DIMENSAO):
            peca = tabuleiro[l][c]
            if peca != "--": #não é quadrado vazio
                tela.blit(IMAGENS[peca], x.Rect(c*SQ_SIZE, l*SQ_SIZE, SQ_SIZE, SQ_SIZE))

"""
Draws the move log.
"""
def DesenharMoveLog(tela, aj, fonte):
    MoveLogRect = x.Rect(LARGURATABULEIRO, 0, LARGURAPAINELMOVELOG, ALTURAPAINELMOVELOG)
    x.draw.rect(tela, x.Color('black'), MoveLogRect)
    MoveLog = aj.MoveLog
    MoveTextos = []
    for i in range(0, len(MoveLog), 2):
        MoverString = str(i // 2 + 1) + '. ' + str(MoveLog[i]) + " "
        if i + 1 < len(MoveLog):
            MoverString += str(MoveLog[i + 1]) + "  "
        MoveTextos.append(MoverString)

    MovimentosPorLinha = 3
    padding = 5
    LineSpacing = 2
    textoY = padding
    for i in range(0, len(MoveTextos), MovimentosPorLinha):
        texto = ""
        for j in range(MovimentosPorLinha):
            if i + j < len(MoveTextos):
                texto += MoveTextos[i + j]
        ObjetoTexto = fonte.render(texto, True, x.Color('white'))
        LocalizacaoTexto = MoveLogRect.move(padding, textoY)
        tela.blit(ObjetoTexto, LocalizacaoTexto)
        textoY += ObjetoTexto.get_height() + LineSpacing

'''
Animar movimento
'''
def MovimentoAnimado(mover, tela, tabuleiro, tempo):
    global cores
    dL = mover.LinhaFinal - mover.LinhaInicial
    dC = mover.ColFinal - mover.ColInicial
    FramesPorQuad = 10  # frames para mover um quadrado
    ContadorFrames = (abs(dL) + abs(dC)) * FramesPorQuad
    for frame in range(ContadorFrames + 1):
        l, c = (mover.LinhaInicial + dL * frame / ContadorFrames, mover.ColInicial + dC * frame / ContadorFrames)
        DesenharTabuleiro(tela)
        DesenharPecas(tela, tabuleiro)
        # apague a peça movida de seu quadrado final
        cor = cores[(mover.LinhaFinal + mover.ColFinal) % 2]
        QuadFinal = x.Rect(mover.ColFinal * SQ_SIZE, mover.LinhaFinal * SQ_SIZE, SQ_SIZE, SQ_SIZE)
        x.draw.rect(tela, cor, QuadFinal)
        # desenhe a peça capturada no retângulo
        if mover.PecaCapturada != '--':
            if mover.eMovimentoEnpassant:
                LinhaEnpassant = mover.LinhaFinal + 1 if mover.PecaCapturada[0] == 'b' else mover.LinhaFinal - 1
                QuadFinal = x.Rect(mover.ColFinal * SQ_SIZE, LinhaEnpassant * SQ_SIZE, SQ_SIZE, SQ_SIZE)
            tela.blit(IMAGENS[mover.PecaCapturada], QuadFinal)
        # desenhar peça movendo
        tela.blit(IMAGENS[mover.PecaMovida], x.Rect(c * SQ_SIZE, l * SQ_SIZE, SQ_SIZE, SQ_SIZE))
        x.display.flip()
        tempo.tick(60)

def DesenharTextoFimDeJogo(tela, texto, deslocamento_vertical = 0):
    fonte = x.font.SysFont("Helvetica", 32, True, False)

    # Divide o texto em linhas
    linhas = texto.split('\n')

    # Desenha cada linha do texto
    for i, linha in enumerate(linhas):
        TextoObj = fonte.render(linha, 0, x.Color("gray"))
        LocalizacaoTexto = x.Rect(0, 0, LARGURATABULEIRO, ALTURATABULEIRO).move(
            LARGURATABULEIRO / 2 - TextoObj.get_width() / 2,
            ALTURATABULEIRO / 2 - TextoObj.get_height() / 2 + i * 40 + deslocamento_vertical  # Ajuste vertical baseado na linha
        )
        tela.blit(TextoObj, LocalizacaoTexto)

        # Adiciona sombra
        TextoObj = fonte.render(linha, 0, x.Color('black'))
        tela.blit(TextoObj, LocalizacaoTexto.move(2, 2))

def perguntar_empate_por_repeticao(tela):
        DesenharTextoFimDeJogo(tela, 'Repetição de 3 posições detectada. \n Declarar empate?')
        botaoSim, botaoNao = DesenharBotaoEmpate3Movimentos(tela)  # Desenha os botões "Sim" e "Não"
        
        empateEscolhido = False  # Flag para saber se o jogador já fez uma escolha
        
        while not empateEscolhido:
            for e in x.event.get():
                if e.type == x.QUIT:
                    return  # Sai do jogo
                elif e.type == x.MOUSEBUTTONDOWN:  # Verifica se um botão foi clicado
                    pos = x.mouse.get_pos()  # Pega a posição do clique
                    
                    if botaoSim.collidepoint(pos):  # Jogador clicou em "Sim"
                        FimDoJogo = True
                        DesenharTextoFimDeJogo(tela, 'Empate por repetição de 3 posições', -70)  # Mostra a mensagem de empate
                        x.display.update()
                        x.time.delay(3000)  # Pausa para o jogador ver a mensagem final de empate
                        empateEscolhido = True  # Jogador escolheu empatar
                        
                    elif botaoNao.collidepoint(pos):  # Jogador clicou em "Não"
                        empateEscolhido = True  # Jogador escolheu continuar jogando

if __name__ == "__main__":
    Principal()




xadrezBack:

import xadrezPrincipal
class ArmazenamentoJogo():
    def __init__(self):
        self.tabuleiro = [
            #tabuleiro em forma de lista 8x8 de 2 dimensões
            #composto por 2 caracteres onde representam as peças de acordo com a conotação atual do xadrez
            #1st caractere = color, 2nd = tipo da peça
            #"--" representa espaços em branco
            ["bR","bN","bB","bQ","bK","bB","bN","bR"],
            ["bP","bP","bP","bP","bP","bP","bP","bP"],
            ["--","--","--","--","--","--","--","--"],
            ["--","--","--","--","--","--","--","--"],
            ["--","--","--","--","--","--","--","--"],
            ["--","--","--","--","--","--","--","--"],
            ["wP","wP","wP","wP","wP","wP","wP","wP"],
            ["wR","wN","wB","wQ","wK","wB","wN","wR"]
        ]
        self.FuncaoMovimentos = {'P' : self.getMovimentosPeao, 'R' : self.getMovimentosTorre, 'N' : self.getMovimentosCavalo,
                                'B' : self.getMovimentosBispo, 'Q' : self.getMovimentosRainha, 'K' : self.getMovimentosRei}
        self.whiteToMove = True
        self.MoveLog = []
        self.LocalizacaoReiBranco = (7, 4)
        self.LocalizacaoReiPreto = (0, 4)
        self.Chequemate = False
        self.Impasse = False
        self.em_Cheque = False
        self.pins = []
        self.cheques = []
        self.EnpassantPossivel = () #coordenadas para o quadrado onde o enpassant é possível
        self.EnpassantPossivelLog = [self.EnpassantPossivel]
        self.DireitoRoqueAtual = DireitosRoque(True, True, True, True)
        self.DireitosRoqueLog = [DireitosRoque(self.DireitoRoqueAtual.wks, self.DireitoRoqueAtual.bks,
                                                self.DireitoRoqueAtual.wqs, self.DireitoRoqueAtual.bqs)]
        self.Empate50Movimentos = False #Variavel para indicar empate
        #ESTE TIPO DE EMPATE NÃO FUNCIONA CONTRA IA, IMPROVAVEL A SUA IMPLEMENTAÇÃO PARA O MODO DE JOGO PLAYER VS IA
        self.Contador50Movimentos = 0  # Contador para rastrear a regra dos 50 movimentos
        self.HistoricoContadores = []
        self.pontuacaoBrancas = 0  # Inicializa a pontuação das peças brancas
        self.pontuacaoPretas = 0   # Inicializa a pontuação das peças pretas
        self.tempo_restante = 0
        self.historicoPosicoes = {}

    '''
    Pega um movimento como um parametro e executa(isso n funcionará para roques, promoção de peão e en-passant)
    '''
    def FazerMovimento(self, mover, tela = None):
        self.HistoricoContadores.append(self.Contador50Movimentos)
        self.tabuleiro[mover.LinhaInicial][mover.ColInicial] = "--"
        self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = mover.PecaMovida
        self.MoveLog.append(mover)#guardar o movimento para poder voltar depois
        self.whiteToMove = not self.whiteToMove #trocar turno
        #atualiza a localização do rei se movido

        # Se foi captura ou movimento de peão, resetar o contador
        if mover.PecaCapturada != '--' or mover.PecaMovida[1] == 'P':  
            self.Contador50Movimentos = 0
        else:
            self.Contador50Movimentos += 1

        # Verificar regra dos 50 movimentos (100 no total, 50 para cada lado)
        if self.Contador50Movimentos >= 100:  # Contagem inclui os dois jogadores
            self.Empate50Movimentos = True

        if mover.PecaMovida == 'wK':
            self.LocalizacaoReiBranco = (mover.LinhaFinal, mover.ColFinal)
        elif mover.PecaMovida == 'bK':
            self.LocalizacaoReiPreto = (mover.LinhaFinal, mover.ColFinal)

        #Promoção de Peão
        if mover.ePromocaoPeao:
            #if not is_AI:
            #    PecaPromovida = input("Promover para Q, R, B, or N:") #take this to UI later
            #    self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = mover.pecaMovida[0] + PecaPromovida
            #else:
            self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = mover.PecaMovida[0] + 'Q'
        
        #Movimento Enpassant 
        if mover.eMovimentoEnpassant:
            self.tabuleiro[mover.LinhaInicial][mover.ColFinal] = '--' #capturando o peão

        #atualizar a variável enpassantPossivel
        if mover.PecaMovida[1] == 'P' and abs(mover.LinhaInicial - mover.LinhaFinal) == 2: #somente em avanço de peao de 2 quadrados
            self.EnpassantPossivel = ((mover.LinhaInicial + mover.LinhaFinal)//2, mover.ColInicial)
        else:
            self.EnpassantPossivel = ()

        #Movimento Roque
        if mover.eMovimentoRoque:
            if mover.ColFinal - mover.ColInicial == 2:  # movimento de roque do lado do rei
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 1] = self.tabuleiro[mover.LinhaFinal][
                    mover.ColFinal + 1]  # move a torre para o outro quadrado
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1] = '--'  # apagar torre antiga
            else:  # movimento de roque do lado da rainha
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1] = self.tabuleiro[mover.LinhaFinal][
                    mover.ColFinal - 2]  # move a torre para o outro quadrado
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 2] = '--'  # apagar torre antiga

        self.EnpassantPossivelLog.append(self.EnpassantPossivel)
        #Atualizar direitos de Roque - sempre que for uma torre ou um movimento de rei
        self.AtualizarDireitosRoque(mover)
        self.DireitosRoqueLog.append(DireitosRoque(self.DireitoRoqueAtual.wks, self.DireitoRoqueAtual.bks,
                                                self.DireitoRoqueAtual.wqs, self.DireitoRoqueAtual.bqs))
        
        # Atualiza o histórico de posições após o movimento
        self.atualizar_historico_posicoes()

        # Verificar repetição de 3 posições após o movimento
        if self.verificar_repeticao_posicoes() and tela is not None:
            xadrezPrincipal.perguntar_empate_por_repeticao(tela)

    '''
    desfazer o ultimo movimento feito
    '''
    def DesfazerMovimento(self):
        if len(self.MoveLog) != 0: #tenha certeza que há um movimento para desfazer
            mover = self.MoveLog.pop()
            self.tabuleiro[mover.LinhaInicial][mover.ColInicial] = mover.PecaMovida
            self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = mover.PecaCapturada
            self.whiteToMove = not self.whiteToMove #trocar time de volta
            #Atualiza a localização do rei se preciso
            if mover.PecaMovida == 'wK':
                self.LocalizacaoReiBranco = (mover.LinhaInicial, mover.ColInicial)
            elif mover.PecaMovida == 'bK':
                self.LocalizacaoReiPreto = (mover.LinhaInicial, mover.ColInicial)
            #desfazer movimento enpassant
            if mover.eMovimentoEnpassant:
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = '--' #deixar os quadrados vazios
                self.tabuleiro[mover.LinhaInicial][mover.ColFinal] = mover.PecaCapturada
                self.EnpassantPossivel = (mover.LinhaFinal, mover.ColFinal)

            self.EnpassantPossivelLog.pop()
            self.EnpassantPossivel = self.EnpassantPossivelLog[-1]

            #desfazer avanço de peão de 2 quadrados
            if mover.PecaMovida[1] == 'P' and abs(mover.LinhaInicial - mover.LinhaFinal) == 2:
                self.EnpassantPossivel = ()
        #desfazer direitos de roque
        self.DireitosRoqueLog.pop() #desfazer do novo movimento de roqque do movimento que estamos desfazendo
        NovosDireitos = self.DireitosRoqueLog[-1] #pegar os direitosRoqueAtual para o ultimo da lista
        self.DireitoRoqueAtual = DireitosRoque(NovosDireitos.wks, NovosDireitos.bks, NovosDireitos.wqs, NovosDireitos.bqs)
        #desfazer Movimento Roque
        if mover.eMovimentoRoque:
            if mover.ColFinal - mover.ColInicial == 2:  # lado do rei
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1] = self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 1]
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 1] = '--'
            else:  # lado da rainha
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 2] = self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1]
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1] = '--'
        self.Chequemate = False
        self.Impasse = False
        if self.HistoricoContadores:
            #Restaure o contador do historico
            self.Contador50Movimentos = self.HistoricoContadores.pop()
    
    """
    Atualizar Direitos de Roque conforme o movimento
    """     
    def AtualizarDireitosRoque(self, mover):
        if mover.PecaCapturada == "wR":
            if mover.ColFinal == 0:  # torre esquerda
                self.DireitoRoqueAtual.wqs = False
            elif mover.ColFinal == 7:  # torre direita
                self.DireitoRoqueAtual.wks = False
        elif mover.PecaCapturada == "bR":
            if mover.ColFinal == 0:  # torre esquerda
                self.DireitoRoqueAtual.bqs = False
            elif mover.ColFinal == 7:  # torre direita
                self.DireitoRoqueAtual.bks = False

        if mover.PecaMovida == 'wK':
            self.DireitoRoqueAtual.wks = False
            self.DireitoRoqueAtual.wqs = False
        elif mover.PecaMovida == 'bK':
            self.DireitoRoqueAtual.bks = False
            self.DireitoRoqueAtual.bqs = False
        elif mover.PecaMovida == 'wR':
            if mover.LinhaInicial == 7:
                if mover.ColInicial == 0:  # torre esquerda
                    self.DireitoRoqueAtual.wqs = False
                elif mover.ColInicial == 7:  # torre direita
                    self.DireitoRoqueAtual.wks = False
        elif mover.PecaMovida == 'bR':
            if mover.LinhaInicial == 0:
                if mover.ColInicial == 0:  # torre esquerda
                    self.DireitoRoqueAtual.bqs = False
                elif mover.ColInicial == 7:  # torre direita
                    self.DireitoRoqueAtual.bks = False

    '''
    todos os movimentos considerando check 
    '''

    def getMovimentosValidos(self):
        if self.Empate50Movimentos:
            return [] # Não há mais movimentos válidos após o empate
        TempEnpassantPossivel = self.EnpassantPossivel
        TempDireitosRoque = DireitosRoque(self.DireitoRoqueAtual.wks, self.DireitoRoqueAtual.bks,
                                        self.DireitoRoqueAtual.wqs, self.DireitoRoqueAtual.bqs)
        # Algoritimo avançado
        movimentos = []
        self.em_Cheque, self.pins, self.cheques = self.ChecarParaPinsECheques()

        if self.whiteToMove:
            LinhaRei = self.LocalizacaoReiBranco[0]
            ColRei = self.LocalizacaoReiBranco[1]
        else:
            LinhaRei = self.LocalizacaoReiPreto[0]
            ColRei = self.LocalizacaoReiPreto[1]
        if self.em_Cheque:
            if len(self.cheques) == 1:  # apenas 1 cheque, bloquear o cheque ou mover o rei
                movimentos = self.getTodosMovimentosPossiveis()
                # Para bloquear o cheque você precisa colocar a peça em um dos quadrados entre a peça inimiga e seu rei
                checar = self.cheques[0]  # checar informação
                ChecarLinha = checar[0]
                ChecarCol = checar[1]
                ChecagemPeca = self.tabuleiro[ChecarLinha][ChecarCol]
                QuadradosValidos = []  # quadrados que as peças podem se mover
                # se cavalo, precisa capturar o cavalo ou mover seu rei, outras peças podem ser bloqueadas
                if ChecagemPeca[1] == "N":
                    QuadradosValidos = [(ChecarLinha, ChecarCol)]
                else:
                    for i in range(1, 8):
                        QuadradoValido = (LinhaRei + checar[2] * i,
                                          ColRei + checar[3] * i)  # checar[2] and checar[3] são as direções de cheque
                        QuadradosValidos.append(QuadradoValido)
                        if QuadradoValido[0] == ChecarLinha and QuadradoValido[
                            1] == ChecarCol:
                            break
                # descartar quaisquer movimentos que n bloqueiam o cheque ou mover o rei
                for i in range(len(movimentos) - 1, -1, -1):
                    if movimentos[i].PecaMovida[1] != "K":  # Mover n move o rei então é necessário bloquear ou capturar
                        if not (movimentos[i].LinhaFinal,
                                movimentos[i].ColFinal) in QuadradosValidos:  # mover não bloqueia ou captura peças
                            movimentos.remove(movimentos[i])
            else:  # cheque duplo, rei deve mover
                self.getMovimentosRei(LinhaRei, ColRei, movimentos)
        else:  # sem cheque, todos moviments validos
            movimentos = self.getTodosMovimentosPossiveis()
            if self.whiteToMove:
                self.getMovimentosRoque(self.LocalizacaoReiBranco[0], self.LocalizacaoReiBranco[1], movimentos)
            else:
                self.getMovimentosRoque(self.LocalizacaoReiPreto[0], self.LocalizacaoReiPreto[1], movimentos)

        if len(movimentos) == 0:
            if self.emCheque():
                self.Chequemate = True
            else:
                # TODO Impasse em movimentos repetitivos
                self.Impasse = True
        else:
            self.Chequemate = False
            self.Impasse = False

        self.DireitoRoqueAtual = TempDireitosRoque
        return movimentos
    
    '''
    Determina se o jogador do turno atual está em cheque
    '''
    def emCheque(self):
        if self.whiteToMove:
            return self.QuadSobreAtaque(self.LocalizacaoReiBranco[0], self.LocalizacaoReiBranco[1])
        else:
            return self.QuadSobreAtaque(self.LocalizacaoReiPreto[0], self.LocalizacaoReiPreto[1])

    '''
    Determina se o inimigo consegue atacar o quadrado
    '''
    def QuadSobreAtaque(self, l, c):
        self.whiteToMove = not self.whiteToMove #trocar para o turno do oponente
        movimentosOponente = self.getTodosMovimentosPossiveis()
        self.whiteToMove = not self.whiteToMove #Trocar turnos de volta
        for mover in movimentosOponente:
            if mover.LinhaFinal == l and mover.ColFinal == c: #Quadrado sobre ataque
                return True
        return False
    
    '''
    todos os movimentos sem considerar check
    '''

    def getTodosMovimentosPossiveis(self):
        movimentos = []
        for l in range(len(self.tabuleiro)): #numero de linhas
            for c in range(len(self.tabuleiro[l])): #numero de colunas na devida linha
                turno = self.tabuleiro[l][c][0]
                if (turno == 'w' and self.whiteToMove) or (turno == 'b' and not self.whiteToMove):
                    peca = self.tabuleiro[l][c][1]
                    self.FuncaoMovimentos[peca](l, c, movimentos) #chama a função apropriada para cada peça
        return movimentos
    
    '''
    Retorna se o jogador está em cheque, uma lista de pins e uma lista de cheques
    '''
    def ChecarParaPinsECheques(self):
        pins = [] #quadrados onde a peça pingada aliada está e a direção pingada
        cheques = [] #quadrados onde o inimigo está dando cheque
        em_Cheque = False
        if self.whiteToMove:
            CorInimigo = 'b'
            CorAliado = 'w'
            LinhaInicial = self.LocalizacaoReiBranco[0]
            ColInicial = self.LocalizacaoReiBranco[1]
        else: 
            CorInimigo = 'w'
            CorAliado = 'b'
            LinhaInicial = self.LocalizacaoReiPreto[0]
            ColInicial = self.LocalizacaoReiPreto[1]
        # verifique a partir do rei se há pins e cheques, acompanhe os pins
        direcoes = ((-1, 0), (0, -1), (1, 0), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1))
        for j in range(len(direcoes)):
            d = direcoes[j]
            PinPossivel = () #resetar pins possiveis
            for i in range(1, 8):
                LinhaFinal = LinhaInicial + d[0] * i
                ColFinal = ColInicial + d[1] * i
                if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:
                    PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                    if PecaFinal[0] == CorAliado and PecaFinal[1] != 'K':
                        if PinPossivel == (): #Primeira peça aliada pode ser pingada
                            PinPossivel = (LinhaFinal, ColFinal, d[0], d[1])
                        else: #segunda peça aliada, então sem pin ou cheque possivel nessa direção
                            break
                    elif PecaFinal[0] == CorInimigo:
                        tipoInimigo = PecaFinal[1]
                        if (0 <= j <= 3 and tipoInimigo == 'R') or (4 <= j <= 7 and tipoInimigo == 'B') or (
                            i == 1 and tipoInimigo == 'P' and ((CorInimigo == 'w' and 6 <= j <= 7) or (CorInimigo == 'b' and 4 <= j <= 5))) or (
                                tipoInimigo == 'Q') or (i == 1 and tipoInimigo == 'K'):
                            if PinPossivel == (): #Nenhuma peça bloqueando, então cheque
                                em_Cheque = True
                                cheques.append((LinhaFinal, ColFinal, d[0], d[1]))
                                break
                            else: #Peça bloqueando então tem pin 
                                pins.append(PinPossivel)
                                break
                        else: #Peça inimiga n dando cheque
                            break
                else:
                    break #fora do tabuleiro
        #checar para cheques de cavalo
        movimentosCavalo = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, -1), (2, 1), (-1, -2), (1, -2))
        for mover in movimentosCavalo:
            LinhaFinal = LinhaInicial + mover[0]
            ColFinal = ColInicial + mover[1]
            if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:
                PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                if PecaFinal[0] == CorInimigo and PecaFinal[1] == 'N': #cavalo inimigo atacando o rei
                    em_Cheque = True
                    cheques.append((LinhaFinal, ColFinal, mover[0], mover[1]))
        return em_Cheque, pins, cheques
    
    def verificar_repeticao_posicoes(self):
        """
        Verifica se a posição atual foi repetida 3 vezes.
        """
        posicao_atual = (
            tuple(tuple(peca for peca in linha) for linha in self.tabuleiro),
            self.whiteToMove,
            (self.DireitoRoqueAtual.wks, self.DireitoRoqueAtual.wqs,
            self.DireitoRoqueAtual.bks, self.DireitoRoqueAtual.bqs),
            self.EnpassantPossivel
        )

        return self.historicoPosicoes.get(posicao_atual, 0) >= 3
    
    def atualizar_historico_posicoes(self):
        """
        Atualiza o histórico de posições com a posição atual.
        """
        posicao_atual = (
            tuple(tuple(peca for peca in linha) for linha in self.tabuleiro),
            self.whiteToMove,
            (self.DireitoRoqueAtual.wks, self.DireitoRoqueAtual.wqs,
            self.DireitoRoqueAtual.bks, self.DireitoRoqueAtual.bqs),
            self.EnpassantPossivel
        )

        if posicao_atual in self.historicoPosicoes:
            self.historicoPosicoes[posicao_atual] += 1
        else:
            self.historicoPosicoes[posicao_atual] = 1


    def verificar_empate_por_insuficiencia_material(self, tabuleiro):
        """Verifica se o jogo terminou em empate por insuficiência de material."""
        # Contadores para as peças
        num_rei_branco = 0
        num_rei_preto = 0
        num_bispo_branco = 0
        num_bispo_preto = 0
        num_cavalo_branco = 0
        num_cavalo_preto = 0
        num_outras_brancas = 0
        num_outras_pretas = 0
        # Percorrer o tabuleiro e contar as peças
        for linha in tabuleiro:
            for casa in linha:
                if casa == 'wK':  # Rei branco
                    num_rei_branco += 1
                elif casa == 'bK':  # Rei preto
                    num_rei_preto += 1
                elif casa == 'wB':  # Bispo branco
                    num_bispo_branco += 1
                elif casa == 'bB':  # Bispo preto
                    num_bispo_preto += 1
                elif casa == 'wN':  # Cavalo branco
                    num_cavalo_branco += 1
                elif casa == 'bN':  # Cavalo preto
                    num_cavalo_preto += 1
                # Contar qualquer outra peça que não seja rei, bispo ou cavalo
                elif casa.startswith('w') and casa[1] not in ['K', 'B', 'N']:
                    num_outras_brancas += 1
                elif casa.startswith('b') and casa[1] not in ['K', 'B', 'N']:
                    num_outras_pretas += 1
        # Rei contra Rei
        if num_rei_branco == 1 and num_rei_preto == 1 and \
        num_bispo_branco == 0 and num_bispo_preto == 0 and \
        num_cavalo_branco == 0 and num_cavalo_preto == 0 and \
        num_outras_brancas == 0 and num_outras_pretas == 0:
            return True
        # Rei e Bispo contra Rei
        if (num_rei_branco == 1 and num_rei_preto == 1 and num_bispo_branco == 1 and 
            num_bispo_preto == 0 and num_cavalo_branco == 0 and num_cavalo_preto == 0 and 
            num_outras_brancas == 0 and num_outras_pretas == 0) or \
        (num_rei_branco == 1 and num_rei_preto == 1 and num_bispo_preto == 1 and 
            num_bispo_branco == 0 and num_cavalo_branco == 0 and num_cavalo_preto == 0 and 
            num_outras_brancas == 0 and num_outras_pretas == 0):
            return True
        # Rei e Cavalo contra Rei
        if (num_rei_branco == 1 and num_rei_preto == 1 and num_cavalo_branco == 1 and 
            num_bispo_branco == 0 and num_bispo_preto == 0 and num_cavalo_preto == 0 and 
            num_outras_brancas == 0 and num_outras_pretas == 0) or \
        (num_rei_branco == 1 and num_rei_preto == 1 and num_cavalo_preto == 1 and 
            num_bispo_branco == 0 and num_bispo_preto == 0 and num_cavalo_branco == 0 and 
            num_outras_brancas == 0 and num_outras_pretas == 0):
            return True
        # Rei e Bispo contra Rei e Bispo (mesma cor)
        if num_rei_branco == 1 and num_rei_preto == 1 and \
        num_bispo_branco == 1 and num_bispo_preto == 1 and \
        num_cavalo_branco == 0 and num_cavalo_preto == 0 and \
        num_outras_brancas == 0 and num_outras_pretas == 0:
            # Verificar se os bispos estão na mesma cor de quadrado
            bispo_branco_pos = None
            bispo_preto_pos = None
            for linha_idx, linha in enumerate(tabuleiro):
                for col_idx, casa in enumerate(linha):
                    if casa == 'wB':
                        bispo_branco_pos = (linha_idx, col_idx)
                    elif casa == 'bB':
                        bispo_preto_pos = (linha_idx, col_idx)
            # Verifica se ambos os bispos estão na mesma cor (mesmo padrão de quadrado)
            if bispo_branco_pos and bispo_preto_pos:
                if (bispo_branco_pos[0] + bispo_branco_pos[1]) % 2 == (bispo_preto_pos[0] + bispo_preto_pos[1]) % 2:
                    return True
        # Rei e Bispo de cores opostas (insuficiência de material)
        if num_rei_branco == 1 and num_rei_preto == 1 and \
        num_bispo_branco == 1 and num_bispo_preto == 1 and \
        num_cavalo_branco == 0 and num_cavalo_preto == 0 and \
        num_outras_brancas == 0 and num_outras_pretas == 0:
            # Verificar se os bispos estão em casas opostas
            bispo_branco_pos = None
            bispo_preto_pos = None
            for linha_idx, linha in enumerate(tabuleiro):
                for col_idx, casa in enumerate(linha):
                    if casa == 'wB':
                        bispo_branco_pos = (linha_idx, col_idx)
                    elif casa == 'bB':
                        bispo_preto_pos = (linha_idx, col_idx)
            # Verifica se os bispos estão em casas de cores diferentes
            if bispo_branco_pos and bispo_preto_pos:
                if (bispo_branco_pos[0] + bispo_branco_pos[1]) % 2 != (bispo_preto_pos[0] + bispo_preto_pos[1]) % 2:
                    return True
        # Se não for nenhuma das condições de empate
        return False

    '''
    pegar todos os movimentos para peão localizado na linha, coluna e adicionar esse movimentos para a lista
    '''

    def getMovimentosPeao(self, l, c, movimentos):
        pecaPingada = False
        direcaoPin = ()
        for i in range(len(self.pins) - 1, -1, -1):
            if self.pins[i][0] == l and self.pins[i][1] == c:
                pecaPingada = True
                direcaoPin = (self.pins[i][2], self.pins[i][3])
                self.pins.remove(self.pins[i])
                break

        if self.whiteToMove:
            valorMovimentacao = -1
            LinhaInicial = 6
            CorInimigo = "b"
            LinhaRei, ColRei = self.LocalizacaoReiBranco
        else:
            valorMovimentacao = 1
            LinhaInicial = 1
            CorInimigo = "w"
            LinhaRei, ColRei = self.LocalizacaoReiPreto

        if self.tabuleiro[l + valorMovimentacao][c] == "--":  # Avanço de peão de 1 quadrado
            if not pecaPingada or direcaoPin == (valorMovimentacao, 0):
                movimentos.append(Movimento((l, c), (l + valorMovimentacao, c), self.tabuleiro))
                if l == LinhaInicial and self.tabuleiro[l + 2 * valorMovimentacao][c] == "--":  # Avanço de peão de 2 quadrado
                    movimentos.append(Movimento((l, c), (l + 2 * valorMovimentacao, c), self.tabuleiro))
        if c - 1 >= 0:  # captura para esquerda
            if not pecaPingada or direcaoPin == (valorMovimentacao, -1):
                if self.tabuleiro[l + valorMovimentacao][c - 1][0] == CorInimigo:
                    movimentos.append(Movimento((l, c), (l + valorMovimentacao, c - 1), self.tabuleiro))
                if (l + valorMovimentacao, c - 1) == self.EnpassantPossivel:
                    pecaAtacante = pecaBloqueadora = False
                    if LinhaRei == l:
                        if ColRei < c:  # rei está na esquerda do peão
                            # dentro: entre rei e peão
                            # fora: entre peão e borda
                            faixaInterna = range(ColRei + 1, c - 1)
                            faixaExterna = range(c + 1, 8)
                        else:  # rei na direita do peão
                            faixaInterna = range(ColRei - 1, c, -1)
                            faixaExterna = range(c - 2, -1, -1)
                        for i in faixaInterna:
                            if self.tabuleiro[l][i] != "--":  # alguma peça ao lado de blocos de peões en-passant
                                pecaBloqueadora = True
                        for i in faixaExterna:
                            quad = self.tabuleiro[l][i]
                            if quad[0] == CorInimigo and (quad[1] == "R" or quad[1] == "Q"):
                                pecaAtacante = True
                            elif quad != "--":
                                pecaBloqueadora = True
                    if not pecaAtacante or pecaBloqueadora:
                        movimentos.append(Movimento((l, c), (l + valorMovimentacao, c - 1), self.tabuleiro, eMovimentoEnpassant = True))
        if c + 1 <= 7:  # captura para direita
            if not pecaPingada or direcaoPin == (valorMovimentacao, +1):
                if self.tabuleiro[l + valorMovimentacao][c + 1][0] == CorInimigo:
                    movimentos.append(Movimento((l, c), (l + valorMovimentacao, c + 1), self.tabuleiro))
                if (l + valorMovimentacao, c + 1) == self.EnpassantPossivel:
                    pecaAtacante = pecaBloqueadora = False
                    if LinhaRei == l:
                        if ColRei < c:  # rei está na direita do peão
                            # dentro: entre rei e peão
                            # fora: entre peão e borda
                            faixaInterna = range(ColRei + 1, c)
                            faixaExterna = range(c + 2, 8)
                        else:  # rei na direita do peão
                            faixaInterna = range(ColRei - 1, c + 1, -1)
                            faixaExterna = range(c - 1, -1, -1)
                        for i in faixaInterna:
                            if self.tabuleiro[l][i] != "--":  # alguma peça ao lado de blocos de peões en-passant
                                pecaBloqueadora = True
                        for i in faixaExterna:
                            quad = self.tabuleiro[l][i]
                            if quad[0] == CorInimigo and (quad[1] == "R" or quad[1] == "Q"):
                                pecaAtacante = True
                            elif quad != "--":
                                pecaBloqueadora = True
                    if not pecaAtacante or pecaBloqueadora:
                        movimentos.append(Movimento((l, c), (l + valorMovimentacao, c + 1), self.tabuleiro, eMovimentoEnpassant = True))

    '''
    pegar todos os movimentos para torre localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosTorre(self, l, c, movimentos):
        PecaPingada = False
        DirecaoPin = ()
        for i in range(len(self.pins) - 1, -1, -1):
            if self.pins[i][0] == l and self.pins[i][1] == c:
                PecaPingada = True
                DirecaoPin = (self.pins[i][2], self.pins[i][3])
                if self.tabuleiro[l][c][
                    1] != "Q":  # N pode remover a rainha do pin nos movimentos de torre, somente remove ele nos de bispo
                    self.pins.remove(self.pins[i])
                break
        direcoes = ((-1, 0), (0, -1), (1, 0), (0, 1))  #cima, esquerda, baixo, direita
        CorInimigo = "b" if self.whiteToMove else "w"
        for d in direcoes:
            for i in range(1, 8):
                LinhaFinal = l + d[0] * i
                ColFinal = c + d[1] * i
                if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:  # No tabuleiro
                    if not PecaPingada or DirecaoPin == d or DirecaoPin == (-d[0], -d[1]):
                        PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                        if PecaFinal == "--":  #quadrado vazio valido
                            movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                        elif PecaFinal[0] == CorInimigo:  # capturar peça inimiga
                            movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                            break
                        else:  # peça amiga
                            break
                else:  # fora do tabuleiro
                    break

    '''
    pegar todos os movimentos para cavalo localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosCavalo(self, l, c, movimentos):
        PecaPingada = False
        for i in range(len(self.pins) - 1, -1, -1):
            if self.pins[i][0] == l and self.pins[i][1] == c:
                PecaPingada = True
                self.pins.remove(self.pins[i])
                break
        movimentosCavalo = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, -1), (2, 1), (-1, -2), (1, -2))
        CorAliado = "w" if self.whiteToMove else "b"
        for mover in movimentosCavalo:
            LinhaFinal = l + mover[0]
            ColFinal = c + mover[1]
            if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:
                if not PecaPingada:
                    PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                    if PecaFinal[0] != CorAliado:  #não é uma peça aliada(vazio ou peça inimiga)
                        movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))

    '''
    pegar todos os movimentos para bispo localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosBispo(self, l, c, movimentos):
        PecaPingada = False
        DirecaoPin = ()
        for i in range(len(self.pins) - 1, -1, -1):
            if self.pins[i][0] == l and self.pins[i][1] == c:
                PecaPingada = True
                DirecaoPin = (self.pins[i][2], self.pins[i][3])
                self.pins.remove(self.pins[i])
                break
        direcoes = ((-1, -1), (-1, 1), (1, 1), (1, -1))  # diagonais
        CorInimigo = "b" if self.whiteToMove else "w"
        for d in direcoes:
            for i in range(1, 8):
                LinhaFinal = l + d[0] * i
                ColFinal = c + d[1] * i
                if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:  # checar se o movimento está dentro do tabuleiro
                    if not PecaPingada or DirecaoPin == d or DirecaoPin == (-d[0], -d[1]):
                        PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                        if PecaFinal == "--":  # quadrado vazio é válido
                            movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                        elif PecaFinal[0] == CorInimigo:  # capturar peça inimiga
                            movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                            break
                        else:  # peça aliada
                            break
                else:  # fora do tabuleiro
                    break

    '''
    pegar todos os movimentos para Rainha localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosRainha(self, l, c, movimentos):
        self.getMovimentosTorre(l, c, movimentos)
        self.getMovimentosBispo(l, c, movimentos)

    '''
    pegar todos os movimentos para Rei localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosRei(self, l, c, movimentos):
        MovimentosLinha = (-1, -1, -1, 0, 0, 1, 1, 1)
        MovimentosCol = (-1, 0, 1, -1, 1, -1, 0, 1)
        CorAliado = "w" if self.whiteToMove else "b"
        for i in range(8):
            LinhaFinal = l + MovimentosLinha[i]
            ColFinal = c + MovimentosCol[i]
            if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:
                PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                if PecaFinal[0] != CorAliado:  # não é peça aliada (vazio ou peça inimiga)
                    #colocar rei no quadrado final e checar se tem cheque
                    if CorAliado == "w":
                        self.LocalizacaoReiBranco = (LinhaFinal, ColFinal)
                    else:
                        self.LocalizacaoReiPreto = (LinhaFinal, ColFinal)
                    em_Cheque, pins, cheques = self.ChecarParaPinsECheques()
                    if not em_Cheque:
                        movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                    #Colocar rei na posição original
                    if CorAliado == "w":
                        self.LocalizacaoReiBranco = (l, c)
                    else:
                        self.LocalizacaoReiPreto = (l, c)

    '''
    Gerar todos os movimentos validos de roque para rei no (l, c) e adiciona-los na lista de movimentos
    '''
    def getMovimentosRoque(self, l, c, movimentos):
        if self.QuadSobreAtaque(l, c):
            return  # não poder fazer roque enquanto estiver sobre cheque
        if (self.whiteToMove and self.DireitoRoqueAtual.wks) or (
                not self.whiteToMove and self.DireitoRoqueAtual.bks):
            self.getMovimentosLadoRei(l, c, movimentos)
        if (self.whiteToMove and self.DireitoRoqueAtual.wqs) or (
                not self.whiteToMove and self.DireitoRoqueAtual.bqs):
            self.getMovimentosLadoRainha(l, c, movimentos)

    def getMovimentosLadoRei(self, l, c, movimentos):
        if self.tabuleiro[l][c + 1] == '--' and self.tabuleiro[l][c + 2] == '--':
            if not self.QuadSobreAtaque(l, c + 1) and not self.QuadSobreAtaque(l, c + 2):
                movimentos.append(Movimento((l, c), (l, c + 2), self.tabuleiro, eMovimentoRoque = True))

    def getMovimentosLadoRainha(self, l, c, movimentos):
        if self.tabuleiro[l][c - 1] == '--' and self.tabuleiro[l][c - 2] == '--' and self.tabuleiro[l][c - 3] == '--':
            if not self.QuadSobreAtaque(l, c - 1) and not self.QuadSobreAtaque(l, c - 2):
                movimentos.append(Movimento((l, c), (l, c - 2), self.tabuleiro, eMovimentoRoque = True))


class DireitosRoque():
    def __init__(self, wks, bks, wqs, bqs):
        self.wks = wks
        self.bks = bks
        self.wqs = wqs
        self.bqs = bqs
    

class Movimento():
    #mapeia teclas para valores
    # tecla = valor
    RanksParaLinhas = {"1" : 7,"2" : 6,"3" : 5,"4" : 4,
                    "5" : 3,"6" : 2,"7" : 1,"8" : 0}
    LinhasParaRanks = {v: t for t, v in RanksParaLinhas.items()}
    ArquivosParaColunas = {"a" : 0,"b" : 1,"c" : 2,"d" : 3,
                        "e" : 4,"f" : 5,"g" : 6,"h" : 7}
    ColunasParaArquivos = {v: t for t, v in ArquivosParaColunas.items()}

    def __init__(self, QuadInicial, QuadFinal, tabuleiro, eMovimentoEnpassant = False, eMovimentoRoque = False):
        self.LinhaInicial = QuadInicial[0]
        self.ColInicial = QuadInicial[1]
        self.LinhaFinal = QuadFinal[0]
        self.ColFinal = QuadFinal[1]
        self.PecaMovida = tabuleiro[self.LinhaInicial][self.ColInicial]
        self.PecaCapturada = tabuleiro[self.LinhaFinal][self.ColFinal]
        #Promoção de peão
        self.ePromocaoPeao = (self.PecaMovida == 'wP' and self.LinhaFinal == 0) or (self.PecaMovida == 'bP' and self.LinhaFinal == 7)
        #En passant
        self.eMovimentoEnpassant = eMovimentoEnpassant
        if self.eMovimentoEnpassant:
            self.PecaCapturada = 'wP' if self.PecaMovida == 'bP' else 'bP'
        #Movimento Roque
        self.eMovimentoRoque = eMovimentoRoque

        self.eCapturada = self.PecaCapturada != "--"
        self.idMovimento = self.LinhaInicial * 1000 + self.ColInicial * 100 + self.LinhaFinal * 10 + self.ColFinal

    '''
    Sobreescrever o metodo do igual
    '''
    def __eq__(self, outro):
        if isinstance(outro, Movimento):
            return self.idMovimento == outro.idMovimento
        return False

    def getNotacaoXadrez(self):
        if self.ePromocaoPeao:
            return self.getRankFile(self.LinhaFinal, self.ColFinal) + "Q"
        if self.eMovimentoRoque:
            if self.ColFinal == 1:
                return "0-0-0"
            else:
                return "0-0"
        if self.eMovimentoEnpassant:
            return self.getRankFile(self.LinhaInicial, self.ColInicial)[0] + "x" + self.getRankFile(self.LinhaFinal, self.LinhaFinal) + " e.p."
        if self.PecaCapturada != "--":
            if self.PecaMovida[1] == "P":
                return self.getRankFile(self.LinhaInicial, self.ColInicial)[0] + "x" + self.getRankFile(self.LinhaFinal, self.ColFinal)
            else:
                return self.PecaMovida[1] + "x" + self.getRankFile(self.LinhaFinal, self.ColFinal)
        else:
            if self.PecaMovida[1] == "P":
                return self.getRankFile(self.LinhaFinal, self.ColFinal)
            else:
                return self.PecaMovida[1] + self.getRankFile(self.LinhaFinal, self.ColFinal)

    def getRankFile(self, l, c):
        return self.ColunasParaArquivos[c] + self.LinhasParaRanks[l]

    def __str__(self):
        if self.eMovimentoRoque:
            return "0-0" if self.ColFinal == 6 else "0-0-0"

        QuadFinal = self.getRankFile(self.LinhaFinal, self.ColFinal)

        if self.PecaMovida[1] == "P":
            if self.eCapturada:
                return self.ColunasParaArquivos[self.ColInicial] + "x" + QuadFinal
            else:
                return QuadFinal + "Q" if self.ePromocaoPeao else QuadFinal

        MoverCorda = self.PecaMovida[1]
        if self.eCapturada:
            MoverCorda += "x"
        return MoverCorda + QuadFinal


    


xadrezIA:

import random

pontuacaoPeca = {"K": 0, "Q": 10, "R": 5, "B": 3, "N": 3, "P": 1}

pontuacaoCavalo = [[1, 1, 1, 1, 1, 1, 1, 1],
                [1, 2, 2, 2, 2, 2, 2, 1],
                [1, 2, 3, 3, 3, 3, 2, 1],
                [1, 2, 3, 4, 4, 3, 2, 1],
                [1, 2, 3, 4, 4, 3, 2, 1],
                [1, 2, 3, 3, 3, 3, 2, 1],
                [1, 2, 2, 2, 2, 2, 2, 1],
                [1, 1, 1, 1, 1, 1, 1, 1]]

pontuacaoBispo = [[4, 3, 2, 1, 1, 2, 3, 4],
                [3, 4, 3, 2, 2, 3, 4, 3],
                [2, 3, 4, 3, 3, 4, 3, 2],
                [1, 2, 3, 4, 4, 3, 2, 1],
                [1, 2, 3, 4, 4, 3, 2, 1],
                [2, 3, 4, 3, 3, 4, 3, 2],
                [3, 4, 3, 2, 2, 3, 4, 3],
                [4, 3, 2, 1, 1, 2, 3, 4]]

pontuacaoTorre = [[4, 3, 4, 4, 4, 4, 3, 4],
            [4, 4, 4, 4, 4, 4, 4, 4],
            [1, 1, 2, 3, 3, 2, 1, 1],
            [1, 2, 3, 4, 4, 3, 2, 1],
            [1, 2, 3, 4, 4, 3, 2, 1],
            [1, 1, 2, 3, 3, 2, 1, 1],
            [4, 4, 4, 4, 4, 4, 4, 4],
            [4, 3, 4, 4, 4, 4, 3, 4]]

pontuacaoRainha = [[1, 1, 1, 3, 1, 1, 1, 1],
                [1, 2, 3, 3, 3, 1, 1, 1],
                [1, 4, 3, 3, 3, 4, 2, 1],
                [1, 2, 3, 3, 3, 2, 2, 1],
                [1, 2, 3, 3, 3, 2, 2, 1],
                [1, 4, 3, 3, 3, 4, 2, 1],
                [1, 1, 2, 3, 3, 1, 1, 1],
                [1, 1, 1, 3, 1, 1, 1, 1]]

pontuacaoPeaoBranco = [[8, 8, 8, 8, 8, 8, 8, 8],
                [8, 8, 8, 8, 8, 8, 8, 8],
                [5, 6, 6, 7, 7, 6, 6, 5],
                [2, 3, 3, 5, 5, 3, 3, 2],
                [1, 2, 3, 4, 4, 3, 2, 1],
                [1, 1, 2, 3, 3, 2, 1, 1],
                [1, 1, 1, 0, 0, 1, 1, 1],
                [0, 0, 0, 0, 0, 0, 0, 0]]

pontuacaoPeaoPreto = [[0, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 1, 0, 0, 1, 1, 1],
                [1, 1, 2, 3, 3, 2, 1, 1],
                [1, 2, 3, 4, 4, 3, 2, 1],
                [2, 3, 3, 5, 5, 3, 3, 2],
                [5, 6, 6, 7, 7, 6, 6, 5],
                [8, 8, 8, 8, 8, 8, 8, 8],
                [8, 8, 8, 8, 8, 8, 8, 8]]

PontuacoesDePecaPosicao = {"N": pontuacaoCavalo, "Q": pontuacaoRainha, "B": pontuacaoBispo, "R": pontuacaoTorre, "bP": pontuacaoPeaoPreto, 
                        "wP": pontuacaoPeaoBranco}

CHEQUEMATE = 1000
IMPASSE = 0
DEPTH = 3

"""
pega e retorna um movimento valido aleatorio
"""

def EncontrarMovimentoAleatorio(movimentosValidos):
    return movimentosValidos[random.randint(0, len(movimentosValidos)-1)]

'''
Encontrar melhor movimento, min max sem recursividade
'''

def EncontrarMelhorMovimentoMinMaxSemREC(aj, movimentosValidos):
    MultiplicadorDeTurno = 1 if aj.whiteToMove else -1
    pontuacaoMinMaxOponente = CHEQUEMATE
    MelhorMovimentoJogador = None
    random.shuffle(movimentosValidos)
    for MovimentoJogador in movimentosValidos:
        aj.FazerMovimento(MovimentoJogador)
        movimentosOponente = aj.getMovimentosValidos()
        if aj.Impasse:
            pontuacaoMaxOponente = IMPASSE
        elif aj.Chequemate:
            pontuacaoMaxOponente = -CHEQUEMATE
        else:
            pontuacaoMaxOponente = -CHEQUEMATE
            for movimentoOponente in movimentosOponente:
                aj.FazerMovimento(movimentoOponente)
                aj.getMovimentosValidos()
                if aj.Chequemate:
                    pontuacao = CHEQUEMATE
                elif aj.Impasse:
                    pontuacao = IMPASSE
                else:
                    pontuacao = -MultiplicadorDeTurno * pontuacaoMaterial(aj.tabuleiro)
                if pontuacao > pontuacaoMaxOponente:
                    pontuacaoMaxOponente = pontuacao
                aj.DesfazerMovimento()
        if pontuacaoMaxOponente < pontuacaoMinMaxOponente:
            pontuacaoMinMaxOponente = pontuacaoMaxOponente
            MelhorMovimentoJogador = MovimentoJogador
        aj.DesfazerMovimento()
    return MelhorMovimentoJogador

'''
método auxiliar para fazer a primeira chamada recursiva
'''
def EncontrarMelhorMovimento(aj, movimentosValidos, returnQueue):
    global ProximoMovimento
    ProximoMovimento = None
    random.shuffle(movimentosValidos)
    # EncontrarMovimentoMinMax(aj, movimentosValidos, DEPTH, aj.whiteToMove)
    EncontrarMovimentoNegaMaxAlphaBeta(aj, movimentosValidos, DEPTH, -CHEQUEMATE, CHEQUEMATE, 1 if aj.whiteToMove else -1)
    returnQueue.put(ProximoMovimento)

def EncontrarMovimentoMinMax(aj, movimentosValidos, depth, whiteToMove):
    global ProximoMovimento
    if depth == 0:
        return pontuacaoMaterial(aj.tabuleiro)
    
    if whiteToMove:
        pontuacaoMax = -CHEQUEMATE
        for mover in movimentosValidos:
            aj.FazerMovimento(mover)
            ProximosMovimentos = aj.getMovimentosValidos()
            pontuacao = EncontrarMovimentoMinMax(aj, ProximosMovimentos, depth - 1, False)
            if pontuacao > pontuacaoMax:
                pontuacaoMax = pontuacao
                if depth == DEPTH:
                    ProximoMovimento = mover
                aj.DesfazerMovimento()
            return pontuacaoMax
        
    else:
        pontuacaoMin = CHEQUEMATE
        for mover in movimentosValidos:
            aj.FazerMovimento(mover)
            ProximosMovimentos = aj.getMovimentosValidos()
            pontuacao = EncontrarMovimentoMinMax(aj, ProximosMovimentos, depth - 1, True)
            if pontuacao < pontuacaoMin:
                pontuacaoMin = pontuacao
                if depth == DEPTH:
                    ProximoMovimento = mover
            aj.DesfazerMovimento()
        return pontuacaoMin

def EncontrarMovimentoNegaMaxAlphaBeta(aj, movimentosValidos, depth, alpha, beta, MultiplicadorDeTurno):
    global ProximoMovimento
    if depth == 0:
        return MultiplicadorDeTurno * pontuacaoTabuleiro(aj)
    # mover ordem - implementar mais tarde
    pontuacaoMax = -CHEQUEMATE
    for mover in movimentosValidos:
        aj.FazerMovimento(mover)
        ProximosMovimentos = aj.getMovimentosValidos()
        pontuacao = -EncontrarMovimentoNegaMaxAlphaBeta(aj, ProximosMovimentos, depth - 1, -beta, -alpha, -MultiplicadorDeTurno)
        if pontuacao > pontuacaoMax:
            pontuacaoMax = pontuacao
            if depth == DEPTH:
                ProximoMovimento = mover
        aj.DesfazerMovimento()
        if pontuacaoMax > alpha:
            alpha = pontuacaoMax
        if alpha >= beta:
            break
    return pontuacaoMax
    
'''
Uma pontuação positiva é boa para as brancas, uma negativa é boa para as pretas
'''
def pontuacaoTabuleiro(aj):
    if aj.Chequemate:
        if aj.whiteToMove:
            return -CHEQUEMATE #pretas vencem
        else:
            return CHEQUEMATE #brancas vencem
    elif aj.Impasse:
        return IMPASSE
    
    pontuacao = 0
    for l in range(len(aj.tabuleiro)):
        for c in range(len(aj.tabuleiro[l])):
            quad = aj.tabuleiro[l][c]
            if quad != "--":
                #pontuação de acordo com a posição
                PontuacaoDePecaPosicao = 0
                if quad[1] != "K": #sem tabela posicional para rei
                    if quad[1] == "P": #para peões
                        PontuacaoDePecaPosicao = PontuacoesDePecaPosicao[quad][l][c]
                    else: #para outras peças
                        PontuacaoDePecaPosicao = PontuacoesDePecaPosicao[quad[1]][l][c]

                if quad[0] == 'w':
                    pontuacao += pontuacaoPeca[quad[1]] + PontuacaoDePecaPosicao
                elif quad[0] == 'b':
                    pontuacao -= pontuacaoPeca[quad[1]] + PontuacaoDePecaPosicao

    return pontuacao


'''
Pontuar o tabuleiro beseado no material
'''
def pontuacaoMaterial(tabuleiro):
    pontuacao = 0
    for l in tabuleiro:
        for quad in l:
            if quad[0] == 'w':
                pontuacao += pontuacaoPeca[quad[1]]
            elif quad[0] == 'b':
                pontuacao -= pontuacaoPeca[quad[1]]
            
    return pontuacao
