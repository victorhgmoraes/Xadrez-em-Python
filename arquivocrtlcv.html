import pygame as x
import xadrezBack, IAXadrez
import sys
from multiprocessing import Process, Queue

BOARDWIDTH = BOARDHEIGHT = 612
MOVELOGPANELWIDTH = 250
MOVELOGPANELHEIGHT = BOARDHEIGHT
DIMENSAO = 8
SQ_SIZE = BOARDHEIGHT // DIMENSAO
MAX_FPS = 15 #15 de acordo com o video
IMAGES = {}

def CarregarImagens():
    pecas = ['wP','wR','wQ','wK','wN','wB','bP','bR','bN','bB','bK','bQ']
    for peca in pecas:
        IMAGES[peca] = x.transform.scale(x.image.load("imagens/" + peca + ".png"), (SQ_SIZE, SQ_SIZE))
        #É possível acessar uma imagem dizendo'IMAGES['wP']'

def Principal():
    x.init()
    tela = x.display.set_mode((BOARDWIDTH + MOVELOGPANELWIDTH, BOARDHEIGHT))
    tempo = x.time.Clock()
    tela.fill(x.Color("white"))
    moveLogFonte = x.font.SysFont("Arial", 20, False, False)
    aj = xadrezBack.ArmazenamentoJogo()
    movimentosValidos = aj.getMovimentosValidos()
    movimentoFeito = False #variavel flag para quando um movimento é feito
    animar = False # variavel flag para quando formos animar um movimento
    CarregarImagens()
    #apenas fazer 1 vez, antes do looping while
    running = True
    quadSelecionado = () #nenhum quadrado selecionado, manter informação do ultimo clique do usuário (tupla: (linha, coluna))
    CliquesJogador = [] #manter informação dos cliques do jogador (2 tuplas [(6,4),(4,4)])
    FimDoJogo = False
    JogadorUm = True #Se uma pessoa estiver jogando de brancas, isso vai ser verdadeiro, se uma IA estiver jogando, então será falso
    JogadorDois = True #Mesmo que o de cima mas de pretas
    IAPensando = False
    ProcessoEncontrarMovimento = None
    MovimentoDesfeito = False
    while running:
        TurnoPessoa = (aj.whiteToMove and JogadorUm) or (not aj.whiteToMove and JogadorDois)
        for e in x.event.get():
            if e.type == x.QUIT:
                running = False
            #mouse handler
            elif e.type == x.MOUSEBUTTONDOWN:
                if not FimDoJogo:
                    localizacao = x.mouse.get_pos() #posição do mouse
                    col = localizacao[0]//SQ_SIZE
                    linha = localizacao[1]//SQ_SIZE
                    if quadSelecionado == (linha, col) or col >= 8: #O usuário clicou no mesmo quadrado duas vezes
                        quadSelecionado = () #deselecionar
                        CliquesJogador = [] #limpar cliques do jogador
                    else:
                        quadSelecionado = (linha, col)
                        CliquesJogador.append(quadSelecionado) #append nos dois primeiro e segundon cliques
                    if len(CliquesJogador) == 2 and TurnoPessoa: #depois do segundo clique
                        mover = xadrezBack.Movimento(CliquesJogador[0], CliquesJogador[1], aj.tabuleiro)
                        print(mover.getNotacaoXadrez())
                        for i in range(len(movimentosValidos)):
                            if mover == movimentosValidos[i]:
                                aj.FazerMovimento(movimentosValidos[i])
                                movimentoFeito = True
                                animar = True
                                quadSelecionado = () #resetar cliques do usuário
                                CliquesJogador = []
                        if not movimentoFeito:
                            CliquesJogador = [quadSelecionado]
            
            #key handlers
            elif e.type == x.KEYDOWN:
                if e.key == x.K_z: #desfaz quando 'z' é pressionado
                    aj.DesfazerMovimento()
                    movimentoFeito = True
                    animar = False
                    FimDoJogo = False
                    if IAPensando:
                        ProcessoEncontrarMovimento.terminate()
                        IAPensando = False
                    MovimentoDesfeito = True
                if e.key == x.K_r: #resetar o tabuleiro quando a tecla 'r' é pressionada
                    aj = xadrezBack.ArmazenamentoJogo()
                    movimentosValidos = aj.getMovimentosValidos()
                    quadSelecionado = ()
                    CliquesJogador = []
                    movimentoFeito = False
                    animar = False
                    FimDoJogo = False
                    if IAPensando:
                        ProcessoEncontrarMovimento.terminate()
                        IAPensando = False
                    MovimentoDesfeito = True
                    
        #Localizador de movimento IA
        if not FimDoJogo and not TurnoPessoa and not MovimentoDesfeito:
            if not IAPensando:
                IAPensando = True
                print("Pensando...")
                returnQueue = Queue() #usado para passar dados entre sequencias de programas
                ProcessoEncontrarMovimento = Process(target = IAXadrez.EncontrarMelhorMovimento, args = (aj, movimentosValidos, returnQueue))
                ProcessoEncontrarMovimento.start() #chama EncontrarMelhorMovimento(aj, movimentosValidos, returnQueue)
                
            if not ProcessoEncontrarMovimento.is_alive():
                MovimentoIA = returnQueue.get()
                if MovimentoIA is None:
                    MovimentoIA = IAXadrez.EncontrarMovimentoAleatorio(movimentosValidos)
                aj.FazerMovimento(MovimentoIA)
                movimentoFeito = True
                animar = True
                IAPensando = False

        if movimentoFeito:
            if animar:
                MovimentoAnimado(aj.moveLog[-1], tela, aj.tabuleiro, tempo)
            movimentosValidos = aj.getMovimentosValidos()
            movimentoFeito = False
            animar = False
            MovimentoDesfeito = False
            run = True
            if mover.ePromocaoPeao:
                run = True
                while run:
                    for event in x.event.get():
                        if event.type == x.KEYDOWN:
                            if event.key == x.K_q:
                                mover.pecaPromovida = mover.pecaMovida[0] + 'Q'  # Promoção para dama
                                run = False
                            elif event.key == x.K_r:
                                mover.pecaPromovida = mover.pecaMovida[0] + 'R'  # Promoção para torre
                                run = False
                            elif event.key == x.K_b:
                                mover.pecaPromovida = mover.pecaMovida[0] + 'B'  # Promoção para bispo
                                run = False
                            elif event.key == x.K_k:
                                mover.pecaPromovida = mover.pecaMovida[0] + 'N'  # Promoção para cavalo
                                run = False

                # Após a escolha da promoção, aplicar a mudança no tabuleiro
                aj.tabuleiro[mover.LinhaFinal][mover.ColFinal] = mover.pecaPromovida


        FazerJogo(tela, aj, movimentosValidos, quadSelecionado, moveLogFonte)

        if aj.Chequemate or aj.Impasse:
            FimDoJogo = True
            DesenharTextoFimDeJogo(tela, 'Empate' if aj.Impasse else 'Pretas vencem por chequemate' if aj.whiteToMove else 'Brancas vencem por chequemate')
                
        tempo.tick(MAX_FPS)
        x.display.flip()

'''
Responsável pela parte gráfica
'''

def FazerJogo(tela, aj, movimentosValidos, quadSelecionado, moveLogFonte):
    DesenharTabuleiro(tela) #desenhar quadrados
    QuadradosBrilhantes(tela, aj, movimentosValidos, quadSelecionado)
    DesenharPecas(tela, aj.tabuleiro) #desenhar peças no topo dos quadrados
    DesenharMoveLog(tela, aj, moveLogFonte)
'''
Desenhar quadrados
'''

def DesenharTabuleiro(tela):
    global cores
    cores = [x.Color("White"), x.Color("grey")]
    for l in range(DIMENSAO):
        for c in range(DIMENSAO):
            cor = cores[((l + c) % 2)]
            x.draw.rect(tela, cor, x.Rect(c*SQ_SIZE, l*SQ_SIZE, SQ_SIZE, SQ_SIZE))
'''
quadrado brilhante selecionado e movimentos para peça selecionada
'''

def QuadradosBrilhantes(tela, aj, movimentosValidos, quadSelecionado):
    if (len(aj.moveLog)) > 0:
        UltimoMovimento = aj.moveLog[-1]
        s = x.Surface((SQ_SIZE, SQ_SIZE))
        s.set_alpha(100)
        s.fill(x.Color('green'))
        tela.blit(s, (UltimoMovimento.ColFinal * SQ_SIZE, UltimoMovimento.LinhaFinal * SQ_SIZE))
    if quadSelecionado != ():
        l, c = quadSelecionado
        if aj.tabuleiro[l][c][0] == (
                'w' if aj.whiteToMove else 'b'):  # Quadrado selecionado é uma peça que pode ser movida
            # Quadrado brilhante selecionado
            s = x.Surface((SQ_SIZE, SQ_SIZE))
            s.set_alpha(100)  # Valor de transparência 0 -> transparentw, 255 -> opaco
            s.fill(x.Color('blue'))
            tela.blit(s, (c * SQ_SIZE, l * SQ_SIZE))
            # movimentos brilhantes desse quadrado
            s.fill(x.Color('yellow'))
            for mover in movimentosValidos:
                if mover.LinhaInicial == l and mover.ColInicial == c:
                    tela.blit(s, (mover.ColFinal * SQ_SIZE, mover.LinhaFinal * SQ_SIZE))
'''
Desenhar peças
'''
def DesenharPecas(tela, tabuleiro):
    for l in range(DIMENSAO):
        for c in range(DIMENSAO):
            peca = tabuleiro[l][c]
            if peca != "--": #não é quadrado vazio
                tela.blit(IMAGES[peca], x.Rect(c*SQ_SIZE, l*SQ_SIZE, SQ_SIZE, SQ_SIZE))

"""
Draws the move log.
"""
def DesenharMoveLog(tela, aj, fonte):
    moveLogRect = x.Rect(BOARDWIDTH, 0, MOVELOGPANELWIDTH, MOVELOGPANELHEIGHT)
    x.draw.rect(tela, x.Color('black'), moveLogRect)
    moveLog = aj.moveLog
    moveTextos = []
    for i in range(0, len(moveLog), 2):
        MoverCorda = str(i // 2 + 1) + '. ' + str(moveLog[i]) + " "
        if i + 1 < len(moveLog):
            MoverCorda += str(moveLog[i + 1]) + "  "
        moveTextos.append(MoverCorda)

    MovimentosPorLinha = 3
    padding = 5
    lineSpacing = 2
    textoY = padding
    for i in range(0, len(moveTextos), MovimentosPorLinha):
        texto = ""
        for j in range(MovimentosPorLinha):
            if i + j < len(moveTextos):
                texto += moveTextos[i + j]

        objetoTexto = fonte.render(texto, True, x.Color('white'))
        localizacaoTexto = moveLogRect.move(padding, textoY)
        tela.blit(objetoTexto, localizacaoTexto)
        textoY += objetoTexto.get_height() + lineSpacing

'''
Animar movimento
'''
def MovimentoAnimado(mover, tela, tabuleiro, tempo):
    global cores
    dL = mover.LinhaFinal - mover.LinhaInicial
    dC = mover.ColFinal - mover.ColInicial
    FramesPorQuad = 10  # frames para mover um quadrado
    ContadorFrames = (abs(dL) + abs(dC)) * FramesPorQuad
    for frame in range(ContadorFrames + 1):
        l, c = (mover.LinhaInicial + dL * frame / ContadorFrames, mover.ColInicial + dC * frame / ContadorFrames)
        DesenharTabuleiro(tela)
        DesenharPecas(tela, tabuleiro)
        # apague a peça movida de seu quadrado final
        cor = cores[(mover.LinhaFinal + mover.ColFinal) % 2]
        QuadFinal = x.Rect(mover.ColFinal * SQ_SIZE, mover.LinhaFinal * SQ_SIZE, SQ_SIZE, SQ_SIZE)
        x.draw.rect(tela, cor, QuadFinal)
        # desenhe a peça capturada no retângulo
        if mover.pecaGravada != '--':
            if mover.eMovimentoEnpassant:
                LinhaEnpassant = mover.LinhaFinal + 1 if mover.pecaGravada[0] == 'b' else mover.LinhaFinal - 1
                QuadFinal = x.Rect(mover.ColFinal * SQ_SIZE, LinhaEnpassant * SQ_SIZE, SQ_SIZE, SQ_SIZE)
            tela.blit(IMAGES[mover.pecaGravada], QuadFinal)
        # desenhar peça movendo
        tela.blit(IMAGES[mover.pecaMovida], x.Rect(c * SQ_SIZE, l * SQ_SIZE, SQ_SIZE, SQ_SIZE))
        x.display.flip()
        tempo.tick(60)

def DesenharTextoFimDeJogo(tela, texto):
    fonte = x.font.SysFont("Helvetica", 32, True, False)
    TextoObj = fonte.render(texto, 0, x.Color("gray"))
    TextoLocalizacao = x.Rect(0, 0, BOARDWIDTH, BOARDHEIGHT).move(BOARDWIDTH / 2 - TextoObj.get_width() / 2, BOARDHEIGHT / 2 - TextoObj.get_height() / 2)
    tela.blit(TextoObj, TextoLocalizacao)
    TextoObj = fonte.render(texto, 0, x.Color('black'))
    tela.blit(TextoObj, TextoLocalizacao.move(2, 2))

if __name__ == "__main__":
    Principal()

    import random

    pontuacaoPeca = {"K": 0, "Q": 10, "R": 5, "B": 3, "N": 3, "P": 1}
    
    pontuacaoCavalo = [[1, 1, 1, 1, 1, 1, 1, 1],
                     [1, 2, 2, 2, 2, 2, 2, 1],
                     [1, 2, 3, 3, 3, 3, 2, 1],
                     [1, 2, 3, 4, 4, 3, 2, 1],
                     [1, 2, 3, 4, 4, 3, 2, 1],
                     [1, 2, 3, 3, 3, 3, 2, 1],
                     [1, 2, 2, 2, 2, 2, 2, 1],
                     [1, 1, 1, 1, 1, 1, 1, 1]]
    
    pontuacaoBispo = [[4, 3, 2, 1, 1, 2, 3, 4],
                     [3, 4, 3, 2, 2, 3, 4, 3],
                     [2, 3, 4, 3, 3, 4, 3, 2],
                     [1, 2, 3, 4, 4, 3, 2, 1],
                     [1, 2, 3, 4, 4, 3, 2, 1],
                     [2, 3, 4, 3, 3, 4, 3, 2],
                     [3, 4, 3, 2, 2, 3, 4, 3],
                     [4, 3, 2, 1, 1, 2, 3, 4]]
    
    pontuacaoTorre = [[4, 3, 4, 4, 4, 4, 3, 4],
                   [4, 4, 4, 4, 4, 4, 4, 4],
                   [1, 1, 2, 3, 3, 2, 1, 1],
                   [1, 2, 3, 4, 4, 3, 2, 1],
                   [1, 2, 3, 4, 4, 3, 2, 1],
                   [1, 1, 2, 3, 3, 2, 1, 1],
                   [4, 4, 4, 4, 4, 4, 4, 4],
                   [4, 3, 4, 4, 4, 4, 3, 4]]
    
    pontuacaoRainha = [[1, 1, 1, 3, 1, 1, 1, 1],
                    [1, 2, 3, 3, 3, 1, 1, 1],
                    [1, 4, 3, 3, 3, 4, 2, 1],
                    [1, 2, 3, 3, 3, 2, 2, 1],
                    [1, 2, 3, 3, 3, 2, 2, 1],
                    [1, 4, 3, 3, 3, 4, 2, 1],
                    [1, 1, 2, 3, 3, 1, 1, 1],
                    [1, 1, 1, 3, 1, 1, 1, 1]]
    
    pontuacaoPeaoBranco = [[8, 8, 8, 8, 8, 8, 8, 8],
                   [8, 8, 8, 8, 8, 8, 8, 8],
                   [5, 6, 6, 7, 7, 6, 6, 5],
                   [2, 3, 3, 5, 5, 3, 3, 2],
                   [1, 2, 3, 4, 4, 3, 2, 1],
                   [1, 1, 2, 3, 3, 2, 1, 1],
                   [1, 1, 1, 0, 0, 1, 1, 1],
                   [0, 0, 0, 0, 0, 0, 0, 0]]
    
    pontuacaoPeaoPreto = [[0, 0, 0, 0, 0, 0, 0, 0],
                   [1, 1, 1, 0, 0, 1, 1, 1],
                   [1, 1, 2, 3, 3, 2, 1, 1],
                   [1, 2, 3, 4, 4, 3, 2, 1],
                   [2, 3, 3, 5, 5, 3, 3, 2],
                   [5, 6, 6, 7, 7, 6, 6, 5],
                   [8, 8, 8, 8, 8, 8, 8, 8],
                   [8, 8, 8, 8, 8, 8, 8, 8]]
    
    PontuacoesDePecaPosicao = {"N": pontuacaoCavalo, "Q": pontuacaoRainha, "B": pontuacaoBispo, "R": pontuacaoTorre, "bP": pontuacaoPeaoPreto, 
                               "wP": pontuacaoPeaoBranco}
    
    CHEQUEMATE = 1000
    IMPASSE = 0
    DEPTH = 3
    
    """
    pega e retorna um movimento valido aleatorio
    """
    
    def EncontrarMovimentoAleatorio(movimentosValidos):
        return movimentosValidos[random.randint(0, len(movimentosValidos)-1)]
    
    '''
    Encontrar melhor movimento, min max sem recursividade
    '''
    
    def EncontrarMelhorMovimentoMinMaxSemREC(aj, movimentosValidos):
        MultiplicadorDeTurno = 1 if aj.whiteToMove else -1
        pontuacaoMinMaxOponente = CHEQUEMATE
        MelhorMovimentoJogador = None
        random.shuffle(movimentosValidos)
        for MovimentoJogador in movimentosValidos:
            aj.FazerMovimento(MovimentoJogador)
            movimentosOponente = aj.getMovimentosValidos()
            if aj.Impasse:
                pontuacaoMaxOponente = IMPASSE
            elif aj.Chequemate:
                pontuacaoMaxOponente = -CHEQUEMATE
            else:
                pontuacaoMaxOponente = -CHEQUEMATE
                for movimentoOponente in movimentosOponente:
                    aj.FazerMovimento(movimentoOponente)
                    aj.getMovimentosValidos()
                    if aj.Chequemate:
                        pontuacao = CHEQUEMATE
                    elif aj.Impasse:
                        pontuacao = IMPASSE
                    else:
                        pontuacao = -MultiplicadorDeTurno * pontuacaoMaterial(aj.tabuleiro)
                    if pontuacao > pontuacaoMaxOponente:
                        pontuacaoMaxOponente = pontuacao
                    aj.DesfazerMovimento()
            if pontuacaoMaxOponente < pontuacaoMinMaxOponente:
                pontuacaoMinMaxOponente = pontuacaoMaxOponente
                MelhorMovimentoJogador = MovimentoJogador
            aj.DesfazerMovimento()
        return MelhorMovimentoJogador
    
    '''
    método auxiliar para fazer a primeira chamada recursiva
    '''
    def EncontrarMelhorMovimento(aj, movimentosValidos, returnQueue):
        global ProximoMovimento
        ProximoMovimento = None
        random.shuffle(movimentosValidos)
        # EncontrarMovimentoMinMax(aj, movimentosValidos, DEPTH, aj.whiteToMove)
        EncontrarMovimentoNegaMaxAlphaBeta(aj, movimentosValidos, DEPTH, -CHEQUEMATE, CHEQUEMATE, 1 if aj.whiteToMove else -1)
        returnQueue.put(ProximoMovimento)
    
    def EncontrarMovimentoMinMax(aj, movimentosValidos, depth, whiteToMove):
        global ProximoMovimento
        if depth == 0:
            return pontuacaoMaterial(aj.tabuleiro)
        
        if whiteToMove:
            pontuacaoMax = -CHEQUEMATE
            for mover in movimentosValidos:
                aj.FazerMovimento(mover)
                ProximosMovimentos = aj.getMovimentosValidos()
                pontuacao = EncontrarMovimentoMinMax(aj, ProximosMovimentos, depth - 1, False)
                if pontuacao > pontuacaoMax:
                    pontuacaoMax = pontuacao
                    if depth == DEPTH:
                        ProximoMovimento = mover
                    aj.DesfazerMovimento()
                return pontuacaoMax
            
        else:
            pontuacaoMin = CHEQUEMATE
            for mover in movimentosValidos:
                aj.FazerMovimento(mover)
                ProximosMovimentos = aj.getMovimentosValidos()
                pontuacao = EncontrarMovimentoMinMax(aj, ProximosMovimentos, depth - 1, True)
                if pontuacao < pontuacaoMin:
                    pontuacaoMin = pontuacao
                    if depth == DEPTH:
                        ProximoMovimento = mover
                aj.DesfazerMovimento()
            return pontuacaoMin
    
    def EncontrarMovimentoNegaMaxAlphaBeta(aj, movimentosValidos, depth, alpha, beta, MultiplicadorDeTurno):
        global ProximoMovimento
        if depth == 0:
            return MultiplicadorDeTurno * pontuacaoTabuleiro(aj)
        # mover ordem - implementar mais tarde
        pontuacaoMax = -CHEQUEMATE
        for mover in movimentosValidos:
            aj.FazerMovimento(mover)
            ProximosMovimentos = aj.getMovimentosValidos()
            pontuacao = -EncontrarMovimentoNegaMaxAlphaBeta(aj, ProximosMovimentos, depth - 1, -beta, -alpha, -MultiplicadorDeTurno)
            if pontuacao > pontuacaoMax:
                pontuacaoMax = pontuacao
                if depth == DEPTH:
                    ProximoMovimento = mover
            aj.DesfazerMovimento()
            if pontuacaoMax > alpha:
                alpha = pontuacaoMax
            if alpha >= beta:
                break
        return pontuacaoMax
        
    '''
    Uma pontuação positiva é boa para as brancas, uma negativa é boa para as pretas
    '''
    def pontuacaoTabuleiro(aj):
        if aj.Chequemate:
            if aj.whiteToMove:
                return -CHEQUEMATE #pretas vencem
            else:
                return CHEQUEMATE #brancas vencem
        elif aj.Impasse:
            return IMPASSE
        
        pontuacao = 0
        for l in range(len(aj.tabuleiro)):
            for c in range(len(aj.tabuleiro[l])):
                quad = aj.tabuleiro[l][c]
                if quad != "--":
                    #pontuação de acordo com a posição
                    PontuacaoDePecaPosicao = 0
                    if quad[1] != "K": #sem tabela posicional para rei
                        if quad[1] == "P": #para peões
                            PontuacaoDePecaPosicao = PontuacoesDePecaPosicao[quad][l][c]
                        else: #para outras peças
                            PontuacaoDePecaPosicao = PontuacoesDePecaPosicao[quad[1]][l][c]
    
                    if quad[0] == 'w':
                        pontuacao += pontuacaoPeca[quad[1]] + PontuacaoDePecaPosicao
                    elif quad[0] == 'b':
                        pontuacao -= pontuacaoPeca[quad[1]] + PontuacaoDePecaPosicao
    
        return pontuacao
    
    
    '''
    Pontuar o tabuleiro beseado no material
    '''
    def pontuacaoMaterial(tabuleiro):
        pontuacao = 0
        for l in tabuleiro:
            for quad in l:
                if quad[0] == 'w':
                    pontuacao += pontuacaoPeca[quad[1]]
                elif quad[0] == 'b':
                    pontuacao -= pontuacaoPeca[quad[1]]
                
        return pontuacao

        class ArmazenamentoJogo():
    def __init__(self):
        self.tabuleiro = [
            #tabuleiro em forma de lista 8x8 de 2 dimensões
            #composto por 2 caracteres onde representam as peças de acordo com a conotação atual do xadrez
            #1st caractere = color, 2nd = tipo da peça
            #"--" representa espaços em branco
            ["bR","bN","bB","bQ","bK","bB","bN","bR"],
            ["bP","bP","bP","bP","bP","bP","bP","bP"],
            ["--","--","--","--","--","--","--","--"],
            ["--","--","--","--","--","--","--","--"],
            ["--","--","--","--","--","--","--","--"],
            ["--","--","--","--","--","--","--","--"],
            ["wP","wP","wP","wP","wP","wP","wP","wP"],
            ["wR","wN","wB","wQ","wK","wB","wN","wR"]
        ]
        self.FuncaoMovimentos = {'P' : self.getMovimentosPeao, 'R' : self.getMovimentosTorre, 'N' : self.getMovimentosCavalo,
                                  'B' : self.getMovimentosBispo, 'Q' : self.getMovimentosRainha, 'K' : self.getMovimentosRei}
        self.whiteToMove = True
        self.moveLog = []
        self.LocalizacaoReiBranco = (7, 4)
        self.LocalizacaoReiPreto = (0, 4)
        self.Chequemate = False
        self.Impasse = False
        self.em_Cheque = False
        self.pins = []
        self.cheques = []
        self.EnpassantPossivel = () #coordenadas para o quadrado onde o enpassant é possível
        self.EnpassantPossivelLog = [self.EnpassantPossivel]
        self.DireitoRoqueAtual = DireitosRoque(True, True, True, True)
        self.DireitosRoqueLog = [DireitosRoque(self.DireitoRoqueAtual.wks, self.DireitoRoqueAtual.bks,
                                                self.DireitoRoqueAtual.wqs, self.DireitoRoqueAtual.bqs)]


    '''
    Pega um movimento como um parametro e executa(isso n funcionará para roques, promoção de peão e en-passant)
    '''
    def FazerMovimento(self, mover):
        self.tabuleiro[mover.LinhaInicial][mover.ColInicial] = "--"
        self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = mover.pecaMovida
        self.moveLog.append(mover)#guardar o movimento para poder voltar depois
        self.whiteToMove = not self.whiteToMove #trocar turno
        #atualiza a localização do rei se movido
        if mover.pecaMovida == 'wK':
            self.LocalizacaoReiBranco = (mover.LinhaFinal, mover.ColFinal)
        elif mover.pecaMovida == 'bK':
            self.LocalizacaoReiPreto = (mover.LinhaFinal, mover.ColFinal)

        #atualizar a variável enpassantPossivel
        if mover.pecaMovida[1] == 'P' and abs(mover.LinhaInicial - mover.LinhaFinal) == 2: #somente em avanço de peao de 2 quadrados
            self.EnpassantPossivel = ((mover.LinhaFinal + mover.LinhaInicial)//2, mover.ColFinal)
        else:
            self.EnpassantPossivel = ()

        #Movimento Enpassant 
        if mover.eMovimentoEnpassant:
            self.tabuleiro[mover.LinhaInicial][mover.ColFinal] = '--' #capturando o peão

        #Promoção de Peão
        if mover.ePromocaoPeao:
                PecaPromovida = input("Promover para Q, R, B, or N:") #take this to UI later
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = mover.pecaMovida[0] + PecaPromovida

        #Movimento Roque
        if mover.eMovimentoRoque:
            if mover.ColFinal - mover.ColInicial == 2:  # movimento de roque do lado do rei
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 1] = self.tabuleiro[mover.LinhaFinal][
                    mover.ColFinal + 1]  # move a torre para o outro quadrado
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1] = '--'  # apagar torre antiga
            else:  # movimento de roque do lado da rainha
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1] = self.tabuleiro[mover.LinhaFinal][
                    mover.ColFinal - 2]  # move a torre para o outro quadrado
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 2] = '--'  # apagar torre antiga

        self.EnpassantPossivelLog.append(self.EnpassantPossivel)
        #Atualizar direitos de Roque - sempre que for uma torre ou um movimento de rei
        self.AtualizarDireitosRoque(mover)
        self.DireitosRoqueLog.append(DireitosRoque(self.DireitoRoqueAtual.wks, self.DireitoRoqueAtual.bks,
                                                self.DireitoRoqueAtual.wqs, self.DireitoRoqueAtual.bqs))
        
    '''
    desfazer o ultimo movimento feito
    '''
    def DesfazerMovimento(self):
        if len(self.moveLog) != 0: #tenha certeza que há um movimento para desfazer
            mover = self.moveLog.pop()
            self.tabuleiro[mover.LinhaInicial][mover.ColInicial] = mover.pecaMovida
            self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = mover.pecaGravada
            self.whiteToMove = not self.whiteToMove #trocar time de volta
            #Atualiza a localização do rei se preciso
            if mover.pecaMovida == 'wK':
                self.LocalizacaoReiBranco = (mover.LinhaInicial, mover.ColInicial)
            elif mover.pecaMovida == 'bK':
                self.LocalizacaoReiPreto = (mover.LinhaInicial, mover.ColInicial)
            #desfazer movimento enpassant
            if mover.eMovimentoEnpassant:
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal] = '--' #deixar os quadrados vazios
                self.tabuleiro[mover.LinhaInicial][mover.ColFinal] = mover.pecaGravada
                self.EnpassantPossivel = (mover.LinhaFinal, mover.ColFinal)

            self.EnpassantPossivelLog.pop()
            self.EnpassantPossivel = self.EnpassantPossivelLog[-1]

            #desfazer avanço de peão de 2 quadrados
            if mover.pecaMovida[1] == 'P' and abs(mover.LinhaInicial - mover.LinhaFinal) == 2:
                self.EnpassantPossivel = ()
        #desfazer direitos de roque
        self.DireitosRoqueLog.pop() #desfazer do novo movimento de roqque do movimento que estamos desfazendo
        novosDireitos = self.DireitosRoqueLog[-1] #pegar os direitosRoqueAtual para o ultimo da lista
        self.DireitoRoqueAtual = DireitosRoque(novosDireitos.wks, novosDireitos.bks, novosDireitos.wqs, novosDireitos.bqs)
        #desfazer Movimento Roque
        if mover.eMovimentoRoque:
            if mover.ColFinal - mover.ColInicial == 2:  # lado do rei
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1] = self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 1]
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 1] = '--'
            else:  # lado da rainha
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal - 2] = self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1]
                self.tabuleiro[mover.LinhaFinal][mover.ColFinal + 1] = '--'
        self.Chequemate = False
        self.Impasse = False


    """
    Atualizar Direitos de Roque conforme o movimento
    """     
    def AtualizarDireitosRoque(self, mover):
        if mover.pecaGravada == "wR":
            if mover.ColFinal == 0:  # torre esquerda
                self.DireitoRoqueAtual.wqs = False
            elif mover.ColFinal == 7:  # torre direita
                self.DireitoRoqueAtual.wks = False
        elif mover.pecaGravada == "bR":
            if mover.ColFinal == 0:  # torre esquerda
                self.DireitoRoqueAtual.bqs = False
            elif mover.ColFinal == 7:  # torre direita
                self.DireitoRoqueAtual.bks = False

        if mover.pecaMovida == 'wK':
            self.DireitoRoqueAtual.wks = False
            self.DireitoRoqueAtual.wqs = False
        elif mover.pecaMovida == 'bK':
            self.DireitoRoqueAtual.bks = False
            self.DireitoRoqueAtual.bqs = False
        elif mover.pecaMovida == 'wR':
            if mover.LinhaInicial == 7:
                if mover.ColInicial == 0:  # torre esquerda
                    self.DireitoRoqueAtual.wqs = False
                elif mover.ColInicial == 7:  # torre direita
                    self.DireitoRoqueAtual.wks = False
        elif mover.pecaMovida == 'bR':
            if mover.LinhaInicial == 0:
                if mover.ColInicial == 0:  # torre esquerda
                    self.DireitoRoqueAtual.bqs = False
                elif mover.ColInicial == 7:  # torre direita
                    self.DireitoRoqueAtual.bks = False

    '''
    todos os movimentos considerando check 
    '''

    def getMovimentosValidos(self):
        tempEnpassantPossivel = self.EnpassantPossivel
        tempDireitosRoque = DireitosRoque(self.DireitoRoqueAtual.wks, self.DireitoRoqueAtual.bks,
                                        self.DireitoRoqueAtual.wqs, self.DireitoRoqueAtual.bqs)
        # Algoritimo avançado
        movimentos = []
        self.em_Cheque, self.pins, self.cheques = self.ChecarParaPinsECheques()

        if self.whiteToMove:
            LinhaRei = self.LocalizacaoReiBranco[0]
            ColRei = self.LocalizacaoReiBranco[1]
        else:
            LinhaRei = self.LocalizacaoReiPreto[0]
            ColRei = self.LocalizacaoReiPreto[1]
        if self.em_Cheque:
            if len(self.cheques) == 1:  # apenas 1 cheque, bloquear o cheque ou mover o rei
                movimentos = self.getTodosMovimentosPossiveis()
                # Para bloquear o cheque você precisa colocar a peça em um dos quadrados entre a peça inimiga e seu rei
                checar = self.cheques[0]  # checar informação
                ChecarLinha = checar[0]
                ChecarCol = checar[1]
                ChecagemPeca = self.tabuleiro[ChecarLinha][ChecarCol]
                QuadradosValidos = []  # quadrados que as peças podem se mover
                # se cavalo, precisa capturar o cavalo ou mover seu rei, outras peças podem ser bloqueadas
                if ChecagemPeca[1] == "N":
                    QuadradosValidos = [(ChecarLinha, ChecarCol)]
                else:
                    for i in range(1, 8):
                        QuadradoValido = (LinhaRei + checar[2] * i,
                                          ColRei + checar[3] * i)  # checar[2] and checar[3] são as direções de cheque
                        QuadradosValidos.append(QuadradoValido)
                        if QuadradoValido[0] == ChecarLinha and QuadradoValido[
                            1] == ChecarCol:
                            break
                # descartar quaisquer movimentos que n bloqueiam o cheque ou mover o rei
                for i in range(len(movimentos) - 1, -1, -1):
                    if movimentos[i].pecaMovida[1] != "K":  # Mover n move o rei então é necessário bloquear ou capturar
                        if not (movimentos[i].LinhaFinal,
                                movimentos[i].ColFinal) in QuadradosValidos:  # mover não bloqueia ou captura peças
                            movimentos.remove(movimentos[i])
            else:  # cheque duplo, rei deve mover
                self.getMovimentosRei(LinhaRei, ColRei, movimentos)
        else:  # sem cheque, todos moviments validos
            movimentos = self.getTodosMovimentosPossiveis()
            if self.whiteToMove:
                self.getMovimentosRoque(self.LocalizacaoReiBranco[0], self.LocalizacaoReiBranco[1], movimentos)
            else:
                self.getMovimentosRoque(self.LocalizacaoReiPreto[0], self.LocalizacaoReiPreto[1], movimentos)

        if len(movimentos) == 0:
            if self.emCheque():
                self.Chequemate = True
            else:
                # Impasse em movimentos repetitivos
                self.Impasse = True
        else:
            self.Chequemate = False
            self.Impasse = False

        self.DireitoRoqueAtual = tempDireitosRoque
        return movimentos
    
    '''
    Determina se o jogador do turno atual está em cheque
    '''
    def emCheque(self):
        if self.whiteToMove:
            return self.QuadSobreAtaque(self.LocalizacaoReiBranco[0], self.LocalizacaoReiBranco[1])
        else:
            return self.QuadSobreAtaque(self.LocalizacaoReiPreto[0], self.LocalizacaoReiPreto[1])

    '''
    Determina se o inimigo consegue atacar o quadrado
    '''
    def QuadSobreAtaque(self, l, c):
        self.whiteToMove = not self.whiteToMove #trocar para o turno do oponente
        movimentosOponente = self.getTodosMovimentosPossiveis()
        self.whiteToMove = not self.whiteToMove #Trocar turnos de volta
        for mover in movimentosOponente:
            if mover.LinhaFinal == l and mover.ColFinal == c: #Quadrado sobre ataque
                return True
        return False
    
    '''
    todos os movimentos sem considerar check
    '''

    def getTodosMovimentosPossiveis(self):
        movimentos = []
        for l in range(len(self.tabuleiro)): #numero de linhas
            for c in range(len(self.tabuleiro[l])): #numero de colunas na devida linha
                turno = self.tabuleiro[l][c][0]
                if (turno == 'w' and self.whiteToMove) or (turno == 'b' and not self.whiteToMove):
                    peca = self.tabuleiro[l][c][1]
                    self.FuncaoMovimentos[peca](l, c, movimentos) #chama a função apropriada para cada peça
        return movimentos
    
    '''
    Retorna se o jogador está em cheque, uma lista de pins e uma lista de cheques
    '''
    def ChecarParaPinsECheques(self):
        pins = [] #quadrados onde a peça pingada aliada está e a direção pingada
        cheques = [] #quadrados onde o inimigo está dando cheque
        em_Cheque = False
        if self.whiteToMove:
            CorInimigo = 'b'
            CorAliado = 'w'
            LinhaInicial = self.LocalizacaoReiBranco[0]
            ColInicial = self.LocalizacaoReiBranco[1]
        else: 
            CorInimigo = 'w'
            CorAliado = 'b'
            LinhaInicial = self.LocalizacaoReiPreto[0]
            ColInicial = self.LocalizacaoReiPreto[1]
        # verifique a partir do rei se há pins e cheques, acompanhe os pins
        direcoes = ((-1, 0), (0, -1), (1, 0), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1))
        for j in range(len(direcoes)):
            d = direcoes[j]
            PinPossivel = () #resetar pins possiveis
            for i in range(1, 8):
                LinhaFinal = LinhaInicial + d[0] * i
                ColFinal = ColInicial + d[1] * i
                if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:
                    PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                    if PecaFinal[0] == CorAliado and PecaFinal[1] != 'K':
                        if PinPossivel == (): #Primeira peça aliada pode ser pingada
                            PinPossivel = (LinhaFinal, ColFinal, d[0], d[1])
                        else: #segunda peça aliada, então sem pin ou cheque possivel nessa direção
                            break
                    elif PecaFinal[0] == CorInimigo:
                        tipoInimigo = PecaFinal[1]
                        #1) ortogonalmente distante do rei e a peça é uma torre
                        #2) diagonalemente distante do rei e a peça é um bispo
                        #3) 1 quadrado de distancia diagonalmente do rei e a peça é um peão
                        #4) qualquer direção e a peça é uma rainha
                        #5) qualquer direção 1 quadrado de distancia e a peça é um rei (Isso é necessário para prevenir um movimento de rei em um quadrado controlado por outro rei)
                        if (0 <= j <= 3 and tipoInimigo == 'R') or (4 <= j <= 7 and tipoInimigo == 'B') or (
                            i == 1 and tipoInimigo == 'P' and ((CorInimigo == 'w' and 6 <= j <= 7) or (CorInimigo == 'b' and 4 <= j <= 5))) or (
                                tipoInimigo == 'Q') or (i == 1 and tipoInimigo == 'K'):
                            if PinPossivel == (): #Nenhuma peça bloqueando, então cheque
                                em_Cheque = True
                                cheques.append((LinhaFinal, ColFinal, d[0], d[1]))
                                break
                            else: #Peça bloqueando então tem pin 
                                pins.append(PinPossivel)
                                break
                        else: #Peça inimiga n dando cheque
                            break
                else:
                    break #fora do tabuleiro
        #checar para cheques de cavalo
        movimentosCavalo = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, -1), (2, 1), (-1, -2), (1, -2))
        for mover in movimentosCavalo:
            LinhaFinal = LinhaInicial + mover[0]
            ColFinal = ColInicial + mover[1]
            if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:
                PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                if PecaFinal[0] == CorInimigo and PecaFinal[1] == 'N': #cavalo inimigo atacando o rei
                    em_Cheque = True
                    cheques.append((LinhaFinal, ColFinal, mover[0], mover[1]))
        return em_Cheque, pins, cheques

    '''
    pegar todos os movimentos para peão localizado na linha, coluna e adicionar esse movimentos para a lista
    '''

    def getMovimentosPeao(self, l, c, movimentos):
        pecaPingada = False
        direcaoPin = ()
        for i in range(len(self.pins) - 1, -1, -1):
            if self.pins[i][0] == l and self.pins[i][1] == c:
                pecaPingada = True
                direcaoPin = (self.pins[i][2], self.pins[i][3])
                self.pins.remove(self.pins[i])
                break

        if self.whiteToMove:
            valorMovimentacao = -1
            LinhaInicial = 6
            CorInimigo = "b"
            LinhaDeVolta = 7
            LinhaRei, ColRei = self.LocalizacaoReiBranco
        else:
            valorMovimentacao = 1
            LinhaInicial = 1
            CorInimigo = "w"
            LinhaDeVolta = 7
            LinhaRei, ColRei = self.LocalizacaoReiPreto
        ePromocaoPeao = False

        if self.tabuleiro[l + valorMovimentacao][c] == "--":  # Avanço de peão de 1 quadrado
            if not pecaPingada or direcaoPin == (valorMovimentacao, 0):
                if l + valorMovimentacao == LinhaDeVolta:
                    ePromocaoPeao = True
                movimentos.append(Movimento((l, c), (l + valorMovimentacao, c), self.tabuleiro, ePromocaoPeao = ePromocaoPeao))
                if l == LinhaInicial and self.tabuleiro[l + 2 * valorMovimentacao][c] == "--":  # Avanço de peão de 2 quadrado
                    movimentos.append(Movimento((l, c), (l + 2 * valorMovimentacao, c), self.tabuleiro))
        if c - 1 >= 0:  # captura para esquerda
            if not pecaPingada or direcaoPin == (valorMovimentacao, -1):
                if self.tabuleiro[l + valorMovimentacao][c - 1][0] == CorInimigo:
                    if l + valorMovimentacao == LinhaDeVolta:
                        ePromocaoPeao = True
                    movimentos.append(Movimento((l, c), (l + valorMovimentacao, c - 1), self.tabuleiro, ePromocaoPeao = ePromocaoPeao))
                if (l + valorMovimentacao, c - 1) == self.EnpassantPossivel:
                    pecaAtacante = pecaBloqueadora = False
                    if LinhaRei == l:
                        if ColRei < c:  # rei está na esquerda do peão
                            # dentro: entre rei e peão
                            # fora: entre peão e borda
                            faixaInterna = range(ColRei + 1, c - 1)
                            faixaExterna = range(c + 1, 8)
                        else:  # rei na direita do peão
                            faixaInterna = range(ColRei - 1, c, -1)
                            faixaExterna = range(c - 2, -1, -1)
                        for i in faixaInterna:
                            if self.tabuleiro[l][i] != "--":  # alguma peça ao lado de blocos de peões en-passant
                                pecaBloqueadora = True
                        for i in faixaExterna:
                            quad = self.tabuleiro[l][i]
                            if quad[0] == CorInimigo and (quad[1] == "R" or quad[1] == "Q"):
                                pecaAtacante = True
                            elif quad != "--":
                                pecaBloqueadora = True
                    if not pecaAtacante or pecaBloqueadora:
                        movimentos.append(Movimento((l, c), (l + valorMovimentacao, c - 1), self.tabuleiro, eMovimentoEnpassant = True))
        if c + 1 <= 7:  # captura para direita
            if not pecaPingada or direcaoPin == (valorMovimentacao, +1):
                if self.tabuleiro[l + valorMovimentacao][c + 1][0] == CorInimigo:
                    if l + valorMovimentacao == LinhaDeVolta:
                        ePromocaoPeao = True
                    movimentos.append(Movimento((l, c), (l + valorMovimentacao, c + 1), self.tabuleiro, ePromocaoPeao = ePromocaoPeao))
                if (l + valorMovimentacao, c + 1) == self.EnpassantPossivel:
                    pecaAtacante = pecaBloqueadora = False
                    if LinhaRei == l:
                        if ColRei < c:  # rei está na direita do peão
                            # dentro: entre rei e peão
                            # fora: entre peão e borda
                            faixaInterna = range(ColRei + 1, c)
                            faixaExterna = range(c + 2, 8)
                        else:  # rei na direita do peão
                            faixaInterna = range(ColRei - 1, c + 1, -1)
                            faixaExterna = range(c - 1, -1, -1)
                        for i in faixaInterna:
                            if self.tabuleiro[l][i] != "--":  # alguma peça ao lado de blocos de peões en-passant
                                pecaBloqueadora = True
                        for i in faixaExterna:
                            quad = self.tabuleiro[l][i]
                            if quad[0] == CorInimigo and (quad[1] == "R" or quad[1] == "Q"):
                                pecaAtacante = True
                            elif quad != "--":
                                pecaBloqueadora = True
                    if not pecaAtacante or pecaBloqueadora:
                        movimentos.append(Movimento((l, c), (l + valorMovimentacao, c + 1), self.tabuleiro, eMovimentoEnpassant = True))

    '''
    pegar todos os movimentos para torre localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosTorre(self, l, c, movimentos):
        PecaPingada = False
        DirecaoPin = ()
        for i in range(len(self.pins) - 1, -1, -1):
            if self.pins[i][0] == l and self.pins[i][1] == c:
                PecaPingada = True
                DirecaoPin = (self.pins[i][2], self.pins[i][3])
                if self.tabuleiro[l][c][
                    1] != "Q":  # N pode remover a rainha do pin nos movimentos de torre, somente remove ele nos de bispo
                    self.pins.remove(self.pins[i])
                break
        direcoes = ((-1, 0), (0, -1), (1, 0), (0, 1))  #cima, esquerda, baixo, direita
        CorInimigo = "b" if self.whiteToMove else "w"
        for d in direcoes:
            for i in range(1, 8):
                LinhaFinal = l + d[0] * i
                ColFinal = c + d[1] * i
                if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:  # No tabuleiro
                    if not PecaPingada or DirecaoPin == d or DirecaoPin == (-d[0], -d[1]):
                        PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                        if PecaFinal == "--":  #quadrado vazio valido
                            movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                        elif PecaFinal[0] == CorInimigo:  # capturar peça inimiga
                            movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                            break
                        else:  # peça amiga
                            break
                else:  # fora do tabuleiro
                    break

    '''
    pegar todos os movimentos para cavalo localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosCavalo(self, l, c, movimentos):
        PecaPingada = False
        for i in range(len(self.pins) - 1, -1, -1):
            if self.pins[i][0] == l and self.pins[i][1] == c:
                PecaPingada = True
                self.pins.remove(self.pins[i])
                break
        movimentosCavalo = ((-2, -1), (-2, 1), (-1, 2), (1, 2), (2, -1), (2, 1), (-1, -2), (1, -2))
        CorAliado = "w" if self.whiteToMove else "b"
        for mover in movimentosCavalo:
            LinhaFinal = l + mover[0]
            ColFinal = c + mover[1]
            if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:
                if not PecaPingada:
                    PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                    if PecaFinal[0] != CorAliado:  #não é uma peça aliada(vazio ou peça inimiga)
                        movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))

    '''
    pegar todos os movimentos para bispo localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosBispo(self, l, c, movimentos):
        PecaPingada = False
        DirecaoPin = ()
        for i in range(len(self.pins) - 1, -1, -1):
            if self.pins[i][0] == l and self.pins[i][1] == c:
                PecaPingada = True
                DirecaoPin = (self.pins[i][2], self.pins[i][3])
                self.pins.remove(self.pins[i])
                break
        direcoes = ((-1, -1), (-1, 1), (1, 1), (1, -1))  # diagonais
        CorInimigo = "b" if self.whiteToMove else "w"
        for d in direcoes:
            for i in range(1, 8):
                LinhaFinal = l + d[0] * i
                ColFinal = c + d[1] * i
                if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:  # checar se o movimento está dentro do tabuleiro
                    if not PecaPingada or DirecaoPin == d or DirecaoPin == (-d[0], -d[1]):
                        PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                        if PecaFinal == "--":  # quadrado vazio é válido
                            movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                        elif PecaFinal[0] == CorInimigo:  # capturar peça inimiga
                            movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                            break
                        else:  # peça aliada
                            break
                else:  # fora do tabuleiro
                    break

    '''
    pegar todos os movimentos para Rainha localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosRainha(self, l, c, movimentos):
        self.getMovimentosTorre(l, c, movimentos)
        self.getMovimentosBispo(l, c, movimentos)

    '''
    pegar todos os movimentos para Rei localizado na linha, coluna e adicionar esse movimentos a lista
    '''

    def getMovimentosRei(self, l, c, movimentos):
        MovimentosLinha = (-1, -1, -1, 0, 0, 1, 1, 1)
        MovimentosCol = (-1, 0, 1, -1, 1, -1, 0, 1)
        CorAliado = "w" if self.whiteToMove else "b"
        for i in range(8):
            LinhaFinal = l + MovimentosLinha[i]
            ColFinal = c + MovimentosCol[i]
            if 0 <= LinhaFinal <= 7 and 0 <= ColFinal <= 7:
                PecaFinal = self.tabuleiro[LinhaFinal][ColFinal]
                if PecaFinal[0] != CorAliado:  # não é peça aliada (vazio ou peça inimiga)
                    #colocar rei no quadrado final e checar se tem cheque
                    if CorAliado == "w":
                        self.LocalizacaoReiBranco = (LinhaFinal, ColFinal)
                    else:
                        self.LocalizacaoReiPreto = (LinhaFinal, ColFinal)
                    em_Cheque, pins, cheques = self.ChecarParaPinsECheques()
                    if not em_Cheque:
                        movimentos.append(Movimento((l, c), (LinhaFinal, ColFinal), self.tabuleiro))
                    #Colocar rei na posição original
                    if CorAliado == "w":
                        self.LocalizacaoReiBranco = (l, c)
                    else:
                        self.LocalizacaoReiPreto = (l, c)

    '''
    Gerar todos os movimentos validos de roque para rei no (l, c) e adiciona-los na lista de movimentos
    '''
    def getMovimentosRoque(self, l, c, movimentos):
        if self.QuadSobreAtaque(l, c):
            return  # não poder fazer roque enquanto estiver sobre cheque
        if (self.whiteToMove and self.DireitoRoqueAtual.wks) or (
                not self.whiteToMove and self.DireitoRoqueAtual.bks):
            self.getMovimentosLadoRei(l, c, movimentos)
        if (self.whiteToMove and self.DireitoRoqueAtual.wqs) or (
                not self.whiteToMove and self.DireitoRoqueAtual.bqs):
            self.getMovimentosLadoRainha(l, c, movimentos)

    def getMovimentosLadoRei(self, l, c, movimentos):
        if self.tabuleiro[l][c + 1] == '--' and self.tabuleiro[l][c + 2] == '--':
            if not self.QuadSobreAtaque(l, c + 1) and not self.QuadSobreAtaque(l, c + 2):
                movimentos.append(Movimento((l, c), (l, c + 2), self.tabuleiro, eMovimentoRoque = True))

    def getMovimentosLadoRainha(self, l, c, movimentos):
        if self.tabuleiro[l][c - 1] == '--' and self.tabuleiro[l][c - 2] == '--' and self.tabuleiro[l][c - 3] == '--':
            if not self.QuadSobreAtaque(l, c - 1) and not self.QuadSobreAtaque(l, c - 2):
                movimentos.append(Movimento((l, c), (l, c - 2), self.tabuleiro, eMovimentoRoque = True))


class DireitosRoque():
    def __init__(self, wks, bks, wqs, bqs):
        self.wks = wks
        self.bks = bks
        self.wqs = wqs
        self.bqs = bqs
    

class Movimento():
    #mapeia teclas para valores
    # tecla = valor
    ranksParaLinhas = {"1" : 7,"2" : 6,"3" : 5,"4" : 4,
                       "5" : 3,"6" : 2,"7" : 1,"8" : 0}
    linhasParaRanks = {v: t for t, v in ranksParaLinhas.items()}
    arquivosParaColunas = {"a" : 0,"b" : 1,"c" : 2,"d" : 3,
                           "e" : 4,"f" : 5,"g" : 6,"h" : 7}
    colunasParaArquivos = {v: t for t, v in arquivosParaColunas.items()}

    def __init__(self, QuadInicial, QuadFinal, tabuleiro, eMovimentoEnpassant = False, ePromocaoPeao = False, eMovimentoRoque = False):
        self.LinhaInicial = QuadInicial[0]
        self.ColInicial = QuadInicial[1]
        self.LinhaFinal = QuadFinal[0]
        self.ColFinal = QuadFinal[1]
        self.pecaMovida = tabuleiro[self.LinhaInicial][self.ColInicial]
        self.pecaGravada = tabuleiro[self.LinhaFinal][self.ColFinal]
        self.ePromocaoPeao = ePromocaoPeao
        #En passant
        self.eMovimentoEnpassant = eMovimentoEnpassant
        if self.eMovimentoEnpassant:
            self.pecaGravada = 'wP' if self.pecaMovida == 'bP' else 'bP'
        #Movimento Roque
        self.eMovimentoRoque = eMovimentoRoque

        self.eCapturada = self.pecaGravada != "--"
        self.idMovimento = self.LinhaInicial * 1000 + self.ColInicial * 100 + self.LinhaFinal * 10 + self.ColFinal

    '''
    Sobreescrever o metodo do igual
    '''
    def __eq__(self, outro):
        if isinstance(outro, Movimento):
            return self.idMovimento == outro.idMovimento
        return False

    def getNotacaoXadrez(self):
        if self.ePromocaoPeao:
            return self.getRankFile(self.LinhaFinal, self.ColFinal) + "Q"
        if self.eMovimentoRoque:
            if self.ColFinal == 1:
                return "0-0-0"
            else:
                return "0-0"
        if self.eMovimentoEnpassant:
            return self.getRankFile(self.LinhaInicial, self.ColInicial)[0] + "x" + self.getRankFile(self.LinhaFinal, self.LinhaFinal) + " e.p."
        if self.pecaGravada != "--":
            if self.pecaMovida[1] == "P":
                return self.getRankFile(self.LinhaInicial, self.ColInicial)[0] + "x" + self.getRankFile(self.LinhaFinal, self.ColFinal)
            else:
                return self.pecaMovida[1] + "x" + self.getRankFile(self.LinhaFinal, self.ColFinal)
        else:
            if self.pecaMovida[1] == "P":
                return self.getRankFile(self.LinhaFinal, self.ColFinal)
            else:
                return self.pecaMovida[1] + self.getRankFile(self.LinhaFinal, self.ColFinal)

    def getRankFile(self, l, c):
        return self.colunasParaArquivos[c] + self.linhasParaRanks[l]

    def __str__(self):
        if self.eMovimentoRoque:
            return "0-0" if self.ColFinal == 6 else "0-0-0"

        QuadFinal = self.getRankFile(self.LinhaFinal, self.ColFinal)

        if self.pecaMovida[1] == "P":
            if self.eCapturada:
                return self.colunasParaArquivos[self.ColInicial] + "x" + QuadFinal
            else:
                return QuadFinal + "Q" if self.ePromocaoPeao else QuadFinal

        MoverCorda = self.pecaMovida[1]
        if self.eCapturada:
            MoverCorda += "x"
        return MoverCorda + QuadFinal